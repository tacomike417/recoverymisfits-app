<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Trudge the Road</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  html, body{
    margin:0; padding:0; height:100%;
    background:#000; overflow:hidden;
    font-family:"Press Start 2P", monospace;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  #pauseBtn{
    position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
    font-family:"Press Start 2P", monospace; font-size:10px;
    padding:10px 14px; background:#111; color:#fff;
    border:1px solid #444; border-radius:8px; opacity:.92; z-index:10;
    display:none;
  }
</style>
</head>

<body>
<canvas id="game"></canvas>
<button id="pauseBtn">PAUSE</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize);
  resize();

  /* =========================
     SPRITE: runner.png
  ========================= */
  const runnerImg = new Image();
  runnerImg.src = "./runner.png";
  let runnerReady = false;
  runnerImg.onload = () => { runnerReady = true; };
  runnerImg.onerror = () => { runnerReady = false; };

  // If runner.png is a sprite sheet, set frames > 1 and adjust source slicing.
  const RUNNER_FRAMES = 1;
  let runnerFrame = 0;
  let runnerTick = 0;
  const RUNNER_FPS = 10;

  /* =========================
     MODES
  ========================= */
  let mode = "title"; // title | countdown | play | pause | gameover | ending

  function setMode(m){
    mode = m;
    document.getElementById("pauseBtn").style.display =
      (mode === "play" || mode === "pause") ? "block" : "none";
  }

  /* =========================
     GAME CONSTANTS
  ========================= */
  const MAX_LIVES = 5;
  const END_COINS = 101;

  // Lanes (3 lanes, tap cycles)
  const LANE_COUNT = 3;
  const laneCenters = () => {
    const top = 130;
    const bottom = innerHeight - 110;
    const gap = (bottom - top) / (LANE_COUNT - 1);
    return [top, top + gap, bottom];
  };

  // Runner placement
  const runner = {
    x: 120,
    y: 0,
    w: 34,
    h: 44,
    lane: 1,      // starts middle
    laneTarget: 1 // for smooth slide
  };

  // Feel (no twitch physics now)
  const BASE_SPEED = 2.9;
  const MAX_SPEED  = 5.2;

  // Spawning: pixel-gap (fair & readable)
  let obstacleGapPx = 420;
  let bonusGapPx = 880;

  // Gentle invulnerability window after hit (prevents ‚Äúdouble hits‚Äù)
  let invuln = 0; // frames

  // Messages / popups
  let popup = null;   // {text, sub, t, ttl}
  let whisper = null; // {text, t, ttl}
  function makePopup(text, sub="", ttl=110){ popup = { text, sub, t:0, ttl }; }
  function makeWhisper(text, ttl=90){ whisper = { text, t:0, ttl }; }

  /* =========================
     RECOVERY CONTENT
  ========================= */
  const obstaclesPool = [
    "Anger","Resentment","Fear","Self-pity","Anxiety","Guilt","Shame",
    "Ego","Overthinking","Self-obsession","Self-righteousness","Control",
    "People-pleasing","Comparison","Relationship drama","Family conflict",
    "Isolation","Unsaid resentment","Not speaking up","Old friends",
    "Work stress","Money worries","Time pressure","Social media","Home chaos","Traffic",
    "Complacency","Dishonesty","Not listening","Selective hearing",
    "Not asking for help","Emotional numbness","Avoidance","Confusion","Uncertainty",
    "Restless","Irritable","Discontent","Catastrophizing","Projection"
  ];

  const bonusesPool = [
    { label:"Go to a meeting", type:"life" },
    { label:"Call a friend", type:"life" },
    { label:"Call your sponsor", type:"life" },
    { label:"Pray / pause", type:"slow" },
    { label:"Write it down", type:"clear" }
  ];

  const coinSayings = [
    "Keep coming back",
    "Just for today",
    "Progress, not perfection",
    "Easy does it",
    "One day at a time",
    "Keep it simple",
    "Let go",
    "Stay in the middle",
    "This too shall pass",
    "First things first"
  ];

  const quietHelps = [
    "Breathe.",
    "Slow down.",
    "Call someone.",
    "You don‚Äôt have to solve this.",
    "Just do the next right thing.",
    "Don‚Äôt do it alone.",
    "Stay in the middle."
  ];

  const statusTable = [
    { c: 1,  name:"Newcomer",                 sub:"Still showing up." },
    { c: 3,  name:"Keep Coming Back",         sub:"It works if we work it." },
    { c: 10, name:"Old Timer",                sub:"Still figuring it out." },
    { c: 25, name:"Grizzled Sober Human",     sub:"Less drama. More truth." },
    { c: 50, name:"Spiritual Janitor",        sub:"Quiet work. No applause." },
    { c: 75, name:"Elder of the Folding Chairs", sub:"Listening is a superpower." },
    { c: 100,name:"Almost There",             sub:"Don‚Äôt rush the miracle." }
  ];
  let lastStatusName = "";

  function maybeStatusUpdate(coins){
    let chosen = null;
    for (const s of statusTable) if (coins >= s.c) chosen = s;
    if (chosen && chosen.name !== lastStatusName){
      lastStatusName = chosen.name;
      makePopup(chosen.name, chosen.sub, 125);
    }
  }

  /* =========================
     STATE
  ========================= */
  let lives = MAX_LIVES;
  let coins = 1; // 24-hour coin
  let obstaclesCleared = 0;
  let lastObstacleLabel = "something";

  const obstacles = []; // {x,y,w,h,label,lane,passed}
  const bonuses = [];   // {x,y,w,h,label,lane,type}

  // effects
  let slowTimer = 0;    // reduces speed temporarily
  let clearNext = false;

  // title/countdown
  let titleTimer = 0;
  let countdownTimer = 0;
  let countdownValue = 3;

  function rand(arr){ return arr[(Math.random()*arr.length)|0]; }

  function currentSpeed(){
    let s = BASE_SPEED + (coins * 0.020) + (Math.floor(obstaclesCleared/50) * 0.10);
    s = Math.min(MAX_SPEED, s);
    if (slowTimer > 0) s *= 0.70;
    return s;
  }

  function resetRun(){
    lives = MAX_LIVES;
    coins = 1;
    obstaclesCleared = 0;
    lastObstacleLabel = "something";
    lastStatusName = "";
    popup = null;
    whisper = null;

    obstacles.length = 0;
    bonuses.length = 0;

    obstacleGapPx = 420;
    bonusGapPx = 880;

    slowTimer = 0;
    clearNext = false;
    invuln = 0;

    runner.lane = 1;
    runner.laneTarget = 1;

    maybeStatusUpdate(coins);
  }

  function startCountdown(){
    resetRun();
    countdownValue = 3;
    countdownTimer = 0;
    setMode("countdown");
  }

  /* =========================
     INPUT: one button cycles lanes
  ========================= */
  function cycleLane(){
    if (mode === "title"){ startCountdown(); return; }
    if (mode === "gameover" || mode === "ending"){ setMode("title"); titleTimer = 0; return; }
    if (mode === "countdown") return;
    if (mode !== "play") return;

    runner.laneTarget = (runner.laneTarget + 1) % LANE_COUNT;
  }

  addEventListener("keydown", (e) => {
    if (e.code === "Space") cycleLane();
  });
  addEventListener("mousedown", cycleLane, {passive:true});
  addEventListener("touchstart", cycleLane, {passive:true});

  // Pause button
  document.getElementById("pauseBtn").onclick = () => {
    if (mode === "play") setMode("pause");
    else if (mode === "pause") setMode("play");
  };

  /* =========================
     SPAWNING
  ========================= */
  function tileSizeForLabel(label, minW, maxW, h){
    const extra = Math.min(260, Math.max(0, (label.length - 10) * 9));
    const w = Math.min(maxW, minW + extra);
    return { w, h };
  }

  function spawnObstacle(){
    const label = rand(obstaclesPool);
    const lanes = laneCenters();
    const lane = (Math.random() * LANE_COUNT) | 0;

    const { w, h } = tileSizeForLabel(label, 160, 380, 30);

    obstacles.push({
      x: innerWidth + 60,
      y: lanes[lane] - h/2,
      w, h,
      label,
      lane,
      passed:false
    });
  }

  function spawnBonus(){
    const b = rand(bonusesPool);
    const lanes = laneCenters();

    // Bias bonuses slightly toward middle lane to feel supportive
    const r = Math.random();
    const lane = r < 0.50 ? 1 : (r < 0.75 ? 0 : 2);

    const { w, h } = tileSizeForLabel(b.label, 210, 420, 28);

    bonuses.push({
      x: innerWidth + 60,
      y: lanes[lane] - h/2,
      w, h,
      label: b.label,
      lane,
      type: b.type
    });
  }

  /* =========================
     COLLISION
  ========================= */
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  /* =========================
     NES-ish title background
  ========================= */
  function drawNesFlashBG(t){
    const phase = (t / 10) | 0;

    // base
    ctx.fillStyle = (phase % 2 === 0) ? "#001" : "#010";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // flashing bands
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = (phase % 2 === 0) ? "#0ff" : "#f0f";
    const bandH = 36;
    for (let y = 0; y < innerHeight; y += bandH){
      if (((y/bandH)|0) % 2 === (phase % 2)) ctx.fillRect(0, y, innerWidth, bandH);
    }
    ctx.globalAlpha = 1;

    // sparkles
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#fff";
    for (let i = 0; i < 90; i++){
      const x = (Math.random() * innerWidth) | 0;
      const y = (Math.random() * innerHeight) | 0;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  /* =========================
     DRAW HELPERS
  ========================= */
  function drawTile(x, y, w, h, kind){
    // kind: "obstacle" | "bonus"
    ctx.fillStyle = (kind === "bonus") ? "#0f0" : "#111";
    ctx.globalAlpha = (kind === "bonus") ? 0.12 : 1;
    ctx.fillRect(x, y, w, h);
    ctx.globalAlpha = 1;

    ctx.strokeStyle = (kind === "bonus") ? "rgba(0,255,0,0.55)" : "#777";
    ctx.strokeRect(x, y, w, h);

    // foot marker
    ctx.fillStyle = (kind === "bonus") ? "rgba(0,255,0,0.35)" : "#444";
    ctx.fillRect(x, y + h - 6, w, 6);
  }

  function drawCenteredLabel(text, x, y, w, h, kind){
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = (kind === "bonus") ? "rgba(0,255,0,0.9)" : "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text.toUpperCase(), x + w/2, y + h/2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  function drawLanes(){
    const lanes = laneCenters();
    ctx.globalAlpha = 0.30;
    ctx.strokeStyle = "#333";
    for (let i = 0; i < lanes.length; i++){
      ctx.beginPath();
      ctx.moveTo(0, lanes[i]);
      ctx.lineTo(innerWidth, lanes[i]);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawRunner(x, y, w, h){
    // animate if sprite sheet
    if (RUNNER_FRAMES > 1 && runnerReady && mode === "play"){
      runnerTick++;
      const frameEvery = Math.max(1, Math.floor(60 / RUNNER_FPS));
      if (runnerTick % frameEvery === 0){
        runnerFrame = (runnerFrame + 1) % RUNNER_FRAMES;
      }
    }

    if (!runnerReady){
      // fallback block
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, w, h);
      ctx.fillRect(x+10, y-8, 14, 8);
      return;
    }

    const imgW = runnerImg.width;
    const imgH = runnerImg.height;

    let sx = 0, sy = 0, sw = imgW, sh = imgH;
    if (RUNNER_FRAMES > 1){
      sw = Math.floor(imgW / RUNNER_FRAMES);
      sh = imgH;
      sx = sw * runnerFrame;
    }

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(runnerImg, sx, sy, sw, sh, x, y, w, h);
  }

  function drawLivesHUD(){
    // User asked for "little 8bit guy" to denote lives.
    // We draw tiny runner icons. If runner isn't ready, fallback to üßç.
    const startX = 12;
    const y = 12;
    const sizeW = 14;
    const sizeH = 18;
    const gap = 6;

    for (let i = 0; i < MAX_LIVES; i++){
      const x = startX + i * (sizeW + gap);
      if (i < lives){
        if (runnerReady){
          // draw tiny sprite
          const imgW = runnerImg.width;
          const imgH = runnerImg.height;
          let sx = 0, sy = 0, sw = imgW, sh = imgH;
          if (RUNNER_FRAMES > 1){
            sw = Math.floor(imgW / RUNNER_FRAMES);
            sh = imgH;
            sx = 0; // first frame for HUD
          }
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(runnerImg, sx, sy, sw, sh, x, y, sizeW, sizeH);
        } else {
          ctx.font = "16px 'Press Start 2P'";
          ctx.fillStyle = "#fff";
          ctx.fillText("üßç", x, y+16);
        }
      } else {
        // empty slot
        ctx.strokeStyle = "#333";
        ctx.strokeRect(x, y, sizeW, sizeH);
      }
    }
  }

  function drawCoinsHUD(){
    // coin emoji in HUD
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "right";
    ctx.fillText(`ü™ô x ${coins}`, innerWidth - 12, 24);
    ctx.textAlign = "left";
  }

  function drawPopupAndWhisper(){
    if (popup){
      popup.t++;
      const alpha = popup.t < 15 ? popup.t/15 : (popup.t > popup.ttl-15 ? (popup.ttl - popup.t)/15 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign="center";
      ctx.fillStyle="#fff";
      ctx.font="10px 'Press Start 2P'";
      ctx.fillText(popup.text, innerWidth/2, 88);
      if (popup.sub) ctx.fillText(popup.sub, innerWidth/2, 108);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
      if (popup.t > popup.ttl) popup = null;
    }

    if (whisper){
      whisper.t++;
      const alpha = whisper.t < 10 ? whisper.t/10 : (whisper.t > whisper.ttl-10 ? (whisper.ttl - whisper.t)/10 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign="center";
      ctx.fillStyle="#fff";
      ctx.font="10px 'Press Start 2P'";
      ctx.fillText(whisper.text, innerWidth/2, innerHeight - 22);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
      if (whisper.t > whisper.ttl) whisper = null;
    }
  }

  function drawOverlay(lines){
    ctx.fillStyle="rgba(0,0,0,0.82)";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";
    ctx.font="10px 'Press Start 2P'";
    let y = innerHeight/2 - 70;
    for (const line of lines){
      ctx.fillText(line, innerWidth/2, y);
      y += 18;
    }
    ctx.font="9px 'Press Start 2P'";
    ctx.fillText("Press Space / Tap", innerWidth/2, y + 24);
    ctx.textAlign="left";
  }

  /* =========================
     UPDATE
  ========================= */
  function updateTitle(){
    titleTimer++;
  }

  function updateCountdown(){
    countdownTimer++;
    if (countdownTimer % 60 === 0){
      countdownValue--;
      if (countdownValue < 0){
        setMode("play");
      }
    }
  }

  function updatePlay(){
    if (coins >= END_COINS){
      setMode("ending");
      return;
    }

    if (invuln > 0) invuln--;
    if (slowTimer > 0) slowTimer--;

    // popups timers
    if (popup && popup.t < popup.ttl) popup.t++;
    if (whisper && whisper.t < whisper.ttl) whisper.t++;

    const lanes = laneCenters();

    // smooth slide to laneTarget
    const targetY = lanes[runner.laneTarget] - runner.h/2;
    const currentY = runner.y;
    const dy = targetY - currentY;
    runner.y = currentY + dy * 0.25; // smoothing
    if (Math.abs(dy) < 0.8){
      runner.y = targetY;
      runner.lane = runner.laneTarget;
    }

    const spd = currentSpeed();

    // move objects
    for (const o of obstacles) o.x -= spd;
    for (const b of bonuses) b.x -= spd;

    // optional clear-next effect (from bonus)
    if (clearNext){
      const next = obstacles.find(o => o.x > runner.x && o.x < runner.x + 360 && o.lane === runner.lane);
      if (next){
        next.x = -9999;
        clearNext = false;
        makeWhisper("Cleared one.", 70);
      }
    }

    // collision boxes for runner
    const rx = runner.x + 6;
    const ry = runner.y + 6;
    const rw = runner.w - 12;
    const rh = runner.h - 10;

    // obstacle collisions ONLY if in same lane
    for (const o of obstacles){
      if (o.lane !== runner.lane) continue;

      // forgiving inset
      const ox = o.x + 10;
      const oy = o.y + 6;
      const ow = Math.max(2, o.w - 20);
      const oh = Math.max(2, o.h - 8);

      if (invuln === 0 && aabb(rx, ry, rw, rh, ox, oy, ow, oh)){
        lives--;
        lastObstacleLabel = o.label;
        invuln = 70; // brief grace period
        o.x = -9999;

        if (lives <= 0){
          setMode("gameover");
          return;
        }
      }

      if (!o.passed && (o.x + o.w) < runner.x){
        o.passed = true;
        obstaclesCleared++;

        // Coin every 12 obstacles cleared
        if (obstaclesCleared % 12 === 0){
          coins++;
          makePopup(rand(coinSayings), "", 90);
          maybeStatusUpdate(coins);
        }

        if (!whisper && Math.random() < 0.012){
          makeWhisper(rand(quietHelps), 90);
        }
      }
    }

    // bonuses collisions (same lane)
    for (const b of bonuses){
      if (b.lane !== runner.lane) continue;

      const bx = b.x + 10;
      const by = b.y + 6;
      const bw = Math.max(2, b.w - 20);
      const bh = Math.max(2, b.h - 10);

      if (aabb(rx, ry, rw, rh, bx, by, bw, bh)){
        if (b.type === "life"){
          const before = lives;
          lives = Math.min(MAX_LIVES, lives + 1);
          makePopup(b.label, (lives > before) ? "+1 life" : "Already full.", 95);
        } else if (b.type === "slow"){
          slowTimer = 240;
          makePopup(b.label, "Quiet for a second.", 100);
        } else if (b.type === "clear"){
          clearNext = true;
          makePopup(b.label, "One obstacle gets cleared.", 100);
        }
        b.x = -9999;
      }
    }

    // cleanup
    for (let i = obstacles.length - 1; i >= 0; i--){
      if (obstacles[i].x < -800) obstacles.splice(i, 1);
    }
    for (let i = bonuses.length - 1; i >= 0; i--){
      if (bonuses[i].x < -800) bonuses.splice(i, 1);
    }

    // spawn spacing
    obstacleGapPx -= spd;
    bonusGapPx -= spd;

    if (obstacleGapPx <= 0){
      spawnObstacle();
      // fair, readable spacing
      obstacleGapPx = 460 + ((Math.random()*260)|0); // 460‚Äì720px
    }
    if (bonusGapPx <= 0 && Math.random() < 0.45){
      spawnBonus();
      bonusGapPx = 920 + ((Math.random()*420)|0); // 920‚Äì1340px
    }
  }

  function update(){
    // expire popup/whisper properly
    if (popup){
      popup.t++;
      if (popup.t > popup.ttl) popup = null;
    }
    if (whisper){
      whisper.t++;
      if (whisper.t > whisper.ttl) whisper = null;
    }

    if (mode === "title") return updateTitle();
    if (mode === "countdown") return updateCountdown();
    if (mode === "pause" || mode === "gameover" || mode === "ending") return;
    if (mode === "play") return updatePlay();
  }

  /* =========================
     DRAW
  ========================= */
  function drawTitle(){
    drawNesFlashBG(titleTimer);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";

    ctx.font="24px 'Press Start 2P'";
    ctx.fillText("TRUDGE", innerWidth/2, innerHeight/2 - 86);
    ctx.fillText("THE ROAD", innerWidth/2, innerHeight/2 - 52);

    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("ONE BUTTON LANE RUNNER", innerWidth/2, innerHeight/2 + 4);

    const blink = ((titleTimer/18)|0) % 2 === 0;
    if (blink){
      ctx.fillText("PRESS SPACE / TAP", innerWidth/2, innerHeight/2 + 56);
    }

    ctx.font="9px 'Press Start 2P'";
    ctx.fillText("TAP TO CHANGE LANES", innerWidth/2, innerHeight/2 + 86);

    ctx.textAlign="left";
  }

  function drawCountdown(){
    drawNesFlashBG(titleTimer + countdownTimer);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";

    ctx.font="16px 'Press Start 2P'";
    ctx.fillText("GET READY", innerWidth/2, innerHeight/2 - 92);

    const show =
      countdownValue >= 1 ? String(countdownValue)
      : countdownValue === 0 ? "GO!"
      : "";

    ctx.font="44px 'Press Start 2P'";
    ctx.fillText(show, innerWidth/2, innerHeight/2 + 10);

    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("SPACE/TAP = CHANGE LANES", innerWidth/2, innerHeight/2 + 86);

    ctx.textAlign="left";
  }

  function drawPlayfield(){
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // subtle lane guides
    drawLanes();

    // runner
    drawRunner(runner.x, runner.y, runner.w, runner.h);

    // obstacles
    for (const o of obstacles){
      drawTile(o.x, o.y, o.w, o.h, "obstacle");
      drawCenteredLabel(o.label, o.x, o.y, o.w, o.h, "obstacle");
    }

    // bonuses
    for (const b of bonuses){
      drawTile(b.x, b.y, b.w, b.h, "bonus");
      drawCenteredLabel(b.label, b.x, b.y, b.w, b.h, "bonus");
    }

    // invuln flicker feedback
    if (invuln > 0){
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#fff";
      ctx.fillRect(runner.x - 6, runner.y - 6, runner.w + 12, runner.h + 12);
      ctx.globalAlpha = 1;
    }

    // HUD (icons)
    drawLivesHUD();
    drawCoinsHUD();

    // popups
    drawPopupAndWhisper();
  }

  function drawEnding(){
    drawOverlay([
      "CONGRATULATIONS.",
      "YOU ARE NOW A SPIRITUAL BEING",
      "WHO HAD A HUMAN EXPERIENCE."
    ]);
  }

  function drawGameOver(){
    drawOverlay([
      `You caught ${lastObstacleLabel}.`,
      "GAME OVER",
      "",
      "Try again ‚Äî or don‚Äôt.",
      "We‚Äôll be here."
    ]);
  }

  function drawPause(){
    drawOverlay(["PAUSED"]);
  }

  function draw(){
    if (mode === "title") return drawTitle();
    if (mode === "countdown") return drawCountdown();

    // playfield visible behind pause/gameover/ending
    drawPlayfield();

    if (mode === "pause") return drawPause();
    if (mode === "gameover") return drawGameOver();
    if (mode === "ending") return drawEnding();
  }

  /* =========================
     MAIN LOOP
  ========================= */
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // init
  resetRun();
  setMode("title");
  // set initial y based on lane
  runner.y = laneCenters()[runner.lane] - runner.h/2;

  loop();
})();
</script>
</body>
</html>
