<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Trudge the Road</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  html, body{
    margin:0;
    padding:0;
    background:#000;
    overflow:hidden;
    height:100%;
    font-family:"Press Start 2P", monospace;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  #pauseBtn{
    position:fixed;
    bottom:10px;
    left:50%;
    transform:translateX(-50%);
    font-family:"Press Start 2P", monospace;
    font-size:10px;
    padding:10px 14px;
    background:#111;
    color:#fff;
    border:1px solid #444;
    border-radius:8px;
    opacity:.92;
    z-index:10;
    display:none; /* show only during play/pause */
  }
</style>
</head>

<body>
<canvas id="game"></canvas>
<button id="pauseBtn">PAUSE</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize);
  resize();

  /* =========================
     MODES
     title -> countdown -> play
     pause, gameover, ending
  ========================= */
  let mode = "title";
  let lives = 5;
  let coins = 1; // 24-hour coin
  let obstaclesCleared = 0;
  let lastObstacleLabel = "something";

  // UX messages
  let popup = null;   // {text, sub, t, ttl}
  let whisper = null; // {text, t, ttl}
  let lastStatusName = "";

  // effects
  let slowTimer = 0;

  // spacing in pixels (fair)
  let obstacleGapPx = 380;
  let bonusGapPx = 760;

  // title / countdown
  let titleTimer = 0;         // frames
  let countdownTimer = 0;     // frames
  let countdownValue = 3;     // 3,2,1,GO

  /* =========================
     CONSTANTS (PLAYABLE)
  ========================= */
  const MAX_LIVES = 5;
  const END_COINS = 101;

  // feel
  const BASE_SPEED = 2.8;
  const MAX_SPEED  = 4.4;
  const GRAVITY    = 0.70;
  const JUMP_VY    = -18.2;     // higher jump

  // jump forgiveness (THIS fixes "wonky")
  const COYOTE_FRAMES = 8;      // can jump shortly after leaving ground
  const BUFFER_FRAMES = 8;      // can queue jump shortly before landing

  // ground
  const GROUND_H = 44;
  const GROUND_Y = () => (innerHeight - GROUND_H);

  /* =========================
     PLAYER
  ========================= */
  const player = {
    x: 90,
    y: 0,
    w: 18,
    h: 34,
    vy: 0,
    onGround: false,
    coyote: 0,
    buffer: 0
  };

  /* =========================
     DATA POOLS
  ========================= */
  const obstaclesPool = [
    "Anger","Resentment","Fear","Self-pity","Anxiety","Guilt","Shame",
    "Ego","Overthinking","Self-obsession","Self-righteousness","Control",
    "People-pleasing","Comparison","Relationship drama","Family conflict",
    "Isolation","Unsaid resentment","Not speaking up","Old friends",
    "Work stress","Money worries","Time pressure","Social media","Home chaos","Traffic",
    "Complacency","Dishonesty","Not listening","Selective hearing",
    "Not asking for help","Emotional numbness","Avoidance","Confusion","Uncertainty"
  ];

  const bonusesPool = [
    { label:"Go to a meeting", type:"life" },
    { label:"Call a friend", type:"life" },
    { label:"Call your sponsor", type:"life" },
    { label:"Pause", type:"slow" },
    { label:"Write it down", type:"clear" }
  ];

  const coinSayings = [
    "Keep coming back",
    "Just for today",
    "Progress, not perfection",
    "Easy does it",
    "One day at a time",
    "Keep it simple",
    "Let go",
    "Stay in the middle",
    "This too shall pass"
  ];

  const quietHelps = [
    "Breathe.",
    "Slow down.",
    "Call someone.",
    "You don’t have to solve this.",
    "Just do the next right thing.",
    "Don’t do it alone."
  ];

  const statusTable = [
    { c: 1,  name:"Newcomer",              sub:"Still showing up." },
    { c: 3,  name:"Keep Coming Back",      sub:"It works if we work it." },
    { c: 10, name:"Old Timer",             sub:"Still figuring it out." },
    { c: 25, name:"Grizzled Sober Human",  sub:"Less drama. More truth." },
    { c: 50, name:"Spiritual Janitor",     sub:"Quiet work. No applause." },
    { c: 75, name:"Elder of the Folding Chairs", sub:"Listening is a superpower." },
    { c: 100,name:"Almost There",          sub:"Don’t rush the miracle." }
  ];

  /* =========================
     OBJECT LISTS
  ========================= */
  const obstacles = [];
  const bonuses = [];

  function rand(arr){ return arr[(Math.random()*arr.length)|0]; }

  function makePopup(text, sub="", ttl=110){ popup = { text, sub, t:0, ttl }; }
  function makeWhisper(text, ttl=90){ whisper = { text, t:0, ttl }; }

  function maybeStatusUpdate(){
    let chosen = null;
    for (const s of statusTable) if (coins >= s.c) chosen = s;
    if (chosen && chosen.name !== lastStatusName){
      lastStatusName = chosen.name;
      makePopup(chosen.name, chosen.sub, 125);
    }
  }

  function onCoinGained(){
    if (Math.random() < 0.85) makePopup(rand(coinSayings), "", 90);
    maybeStatusUpdate();
  }

  function setMode(newMode){
    mode = newMode;
    const pauseBtn = document.getElementById("pauseBtn");
    pauseBtn.style.display = (mode === "play" || mode === "pause") ? "block" : "none";
  }

  function resetRun(){
    lives = 5;
    coins = 1;
    obstaclesCleared = 0;
    lastObstacleLabel = "something";
    popup = null;
    whisper = null;
    lastStatusName = "";
    slowTimer = 0;
    obstacles.length = 0;
    bonuses.length = 0;
    obstacleGapPx = 380;
    bonusGapPx = 760;

    player.y = GROUND_Y() - player.h;
    player.vy = 0;
    player.onGround = true;
    player.coyote = COYOTE_FRAMES;
    player.buffer = 0;

    maybeStatusUpdate();
  }

  function startCountdown(){
    resetRun();
    countdownValue = 3;
    countdownTimer = 0;
    setMode("countdown");
  }

  /* =========================
     INPUT (one button)
  ========================= */
  function queueJump(){
    // Buffer jump so it can trigger on landing
    player.buffer = BUFFER_FRAMES;

    if (mode === "title") {
      startCountdown();
      return;
    }
    if (mode === "gameover" || mode === "ending") {
      setMode("title");
      titleTimer = 0;
      return;
    }
    if (mode !== "play") return;
  }

  addEventListener("keydown", e => {
    if (e.code === "Space") queueJump();
  });
  addEventListener("mousedown", queueJump, {passive:true});
  addEventListener("touchstart", queueJump, {passive:true});

  /* =========================
     PAUSE BUTTON
  ========================= */
  document.getElementById("pauseBtn").onclick = () => {
    if (mode === "play") setMode("pause");
    else if (mode === "pause") setMode("play");
  };

  /* =========================
     COLLISION
  ========================= */
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  /* =========================
     SPAWN (TILES)
  ========================= */
  function spawnObstacle(){
    const label = rand(obstaclesPool);

    // slightly shorter obstacles (easier)
    const h = 34;

    // width based on label length
    const minW = 150;
    const extra = Math.min(240, Math.max(0, (label.length - 10) * 9));
    const w = Math.min(340, minW + extra);

    obstacles.push({
      x: innerWidth + 60,
      y: GROUND_Y() - h,
      w, h,
      label,
      passed:false
    });
  }

  function spawnBonus(){
    const b = rand(bonusesPool);

    const h = 30;
    const minW = 190;
    const extra = Math.min(260, Math.max(0, (b.label.length - 12) * 8));
    const w = Math.min(360, minW + extra);

    bonuses.push({
      x: innerWidth + 60,
      y: GROUND_Y() - 120,
      w, h,
      label: b.label,
      type: b.type
    });
  }

  /* =========================
     SPEED
  ========================= */
  function currentSpeed(){
    let s = BASE_SPEED + (coins * 0.010) + (Math.floor(obstaclesCleared/60) * 0.08);
    s = Math.min(MAX_SPEED, s);
    if (slowTimer > 0) s *= 0.65;
    return s;
  }

  /* =========================
     NES-ish flashing background
  ========================= */
  function drawNesFlashBG(t){
    // alternating blocks + noise dots (simple NES-ish vibe)
    const phase = (t / 10) | 0;

    // base
    ctx.fillStyle = (phase % 2 === 0) ? "#001" : "#010";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // big flashing bands
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = (phase % 2 === 0) ? "#0ff" : "#f0f";
    const bandH = 36;
    for (let y = 0; y < innerHeight; y += bandH){
      if (((y/bandH)|0) % 2 === (phase % 2)) ctx.fillRect(0, y, innerWidth, bandH);
    }
    ctx.globalAlpha = 1;

    // pixel sparkles
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#fff";
    for (let i = 0; i < 90; i++){
      const x = (Math.random() * innerWidth) | 0;
      const y = (Math.random() * innerHeight) | 0;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  /* =========================
     DRAW TILE HELPERS
  ========================= */
  function drawTile(x, y, w, h){
    ctx.fillStyle = "#111";
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = "#777";
    ctx.strokeRect(x, y, w, h);

    // "foot" marker helps timing (clear jump cue)
    ctx.fillStyle = "#444";
    ctx.fillRect(x, y + h - 6, w, 6);
  }

  function drawCenteredLabel(text, x, y, w, h){
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text.toUpperCase(), x + w/2, y + h/2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  /* =========================
     UPDATE
  ========================= */
  function updatePlay(){
    // end at 101
    if (coins >= END_COINS){
      setMode("ending");
      return;
    }

    if (slowTimer > 0) slowTimer--;

    if (popup){
      popup.t++;
      if (popup.t > popup.ttl) popup = null;
    }
    if (whisper){
      whisper.t++;
      if (whisper.t > whisper.ttl) whisper = null;
    }

    // Physics
    player.vy += GRAVITY;
    player.y += player.vy;

    const groundTop = GROUND_Y();
    const wasOnGround = player.onGround;

    if (player.y + player.h >= groundTop){
      player.y = groundTop - player.h;
      player.vy = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }

    // coyote time
    if (player.onGround) player.coyote = COYOTE_FRAMES;
    else player.coyote = Math.max(0, player.coyote - 1);

    // buffer countdown
    if (player.buffer > 0) player.buffer--;

    // Execute buffered jump if possible
    if (player.buffer > 0 && (player.onGround || player.coyote > 0)){
      player.vy = JUMP_VY;
      player.onGround = false;
      player.coyote = 0;
      player.buffer = 0;
    }

    const spd = currentSpeed();

    // Move objects
    for (const o of obstacles) o.x -= spd;
    for (const b of bonuses) b.x -= spd;

    // Obstacles collision/passing
    for (const o of obstacles){
      const hit = aabb(player.x, player.y, player.w, player.h, o.x, o.y, o.w, o.h);
      if (hit){
        lives--;
        lastObstacleLabel = o.label;
        o.x = -9999;

        if (lives <= 0){
          setMode("gameover");
          return;
        }
      }

      if (!o.passed && (o.x + o.w) < player.x){
        o.passed = true;
        obstaclesCleared++;

        // coin every 12 obstacles
        if (obstaclesCleared % 12 === 0){
          coins++;
          onCoinGained();
        }

        // occasional quiet help
        if (!whisper && Math.random() < 0.012) makeWhisper(rand(quietHelps), 90);
      }
    }

    // Bonuses collision
    for (const b of bonuses){
      const got = aabb(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h);
      if (got){
        if (b.type === "life"){
          const before = lives;
          lives = Math.min(MAX_LIVES, lives + 1);
          makePopup(b.label, (lives > before) ? "+1 life" : "Already full.", 95);
        } else if (b.type === "slow"){
          slowTimer = 240;
          makePopup(b.label, "Quiet for a second.", 100);
        } else if (b.type === "clear"){
          const target = obstacles.find(o => o.x > player.x && o.x < player.x + 360);
          if (target) target.x = -9999;
          makePopup(b.label, "Cleared one.", 95);
        }
        b.x = -9999;
      }
    }

    // Cleanup
    for (let i = obstacles.length - 1; i >= 0; i--){
      if (obstacles[i].x < -500) obstacles.splice(i, 1);
    }
    for (let i = bonuses.length - 1; i >= 0; i--){
      if (bonuses[i].x < -500) bonuses.splice(i, 1);
    }

    // Pixel spacing (fair)
    obstacleGapPx -= spd;
    bonusGapPx -= spd;

    if (obstacleGapPx <= 0){
      spawnObstacle();
      // bigger gap = clearer jump timing
      obstacleGapPx = 420 + ((Math.random()*260)|0); // 420–680px
    }

    if (bonusGapPx <= 0 && Math.random() < 0.45){
      spawnBonus();
      bonusGapPx = 860 + ((Math.random()*320)|0); // 860–1180px
    }
  }

  function update(){
    if (mode === "title"){
      titleTimer++;
      // auto-start after a moment, but still lets someone tap/space to start immediately
      if (titleTimer === 90) {
        // optional: auto-start countdown
        // startCountdown();
      }
      return;
    }

    if (mode === "countdown"){
      countdownTimer++;

      // 60 frames per count (~1 second)
      if (countdownTimer % 60 === 0){
        countdownValue--;
        if (countdownValue < 0){
          setMode("play");
        }
      }
      return;
    }

    if (mode === "pause") return;
    if (mode === "gameover") return;
    if (mode === "ending") return;

    if (mode === "play") updatePlay();
  }

  /* =========================
     DRAW
  ========================= */
  function drawHUD(){
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.fillText(`LIVES: ${lives}`, 12, 22);
    ctx.fillText(`COINS: ${coins}`, 12, 38);
    if (slowTimer > 0) ctx.fillText(`QUIET: ${Math.ceil(slowTimer/60)}s`, 12, 54);
  }

  function drawPopupAndWhisper(){
    if (popup){
      const alpha = popup.t < 15 ? popup.t/15 : (popup.t > popup.ttl-15 ? (popup.ttl - popup.t)/15 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign="center";
      ctx.fillStyle="#fff";
      ctx.font="10px 'Press Start 2P'";
      ctx.fillText(popup.text, innerWidth/2, 110);
      if (popup.sub) ctx.fillText(popup.sub, innerWidth/2, 130);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
    }

    if (whisper){
      const alpha = whisper.t < 10 ? whisper.t/10 : (whisper.t > whisper.ttl-10 ? (whisper.ttl - whisper.t)/10 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign="center";
      ctx.fillStyle="#fff";
      ctx.font="10px 'Press Start 2P'";
      ctx.fillText(whisper.text, innerWidth/2, GROUND_Y() - 10);
      ctx.textAlign="left";
      ctx.globalAlpha=1;
    }
  }

  function drawPlayfield(){
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // ground
    ctx.fillStyle = "#222";
    ctx.fillRect(0, GROUND_Y(), innerWidth, GROUND_H);

    // tick marks help timing
    ctx.fillStyle = "#2f2f2f";
    for (let i=0;i<innerWidth;i+=26){
      ctx.fillRect(i, GROUND_Y()+10, 10, 2);
    }

    // player (blocky)
    ctx.fillStyle = "#fff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x+4, player.y-8, 10, 8);

    // obstacles (tiles with centered text)
    for (const o of obstacles){
      drawTile(o.x, o.y, o.w, o.h);
      drawCenteredLabel(o.label, o.x, o.y, o.w, o.h);
    }

    // bonuses (tiles above)
    for (const b of bonuses){
      drawTile(b.x, b.y, b.w, b.h);
      drawCenteredLabel(b.label, b.x, b.y, b.w, b.h);
    }
  }

  function drawTitle(){
    drawNesFlashBG(titleTimer);

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";

    // BIG title
    ctx.font = "20px 'Press Start 2P'";
    ctx.fillText("TRUDGE", innerWidth/2, innerHeight/2 - 70);
    ctx.fillText("THE ROAD", innerWidth/2, innerHeight/2 - 40);

    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText("ONE BUTTON RUNNER", innerWidth/2, innerHeight/2 + 5);

    // flashing prompt
    const blink = ((titleTimer/20)|0) % 2 === 0;
    if (blink) {
      ctx.fillText("PRESS SPACE / TAP TO START", innerWidth/2, innerHeight/2 + 55);
    }

    ctx.textAlign = "left";
  }

  function drawCountdown(){
    // keep the fun background through countdown
    drawNesFlashBG(titleTimer + countdownTimer);

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";

    ctx.font = "16px 'Press Start 2P'";
    ctx.fillText("GET READY", innerWidth/2, innerHeight/2 - 80);

    const show =
      countdownValue >= 1 ? String(countdownValue)
      : countdownValue === 0 ? "GO!"
      : "";

    ctx.font = "36px 'Press Start 2P'";
    ctx.fillText(show, innerWidth/2, innerHeight/2 + 10);

    ctx.font = "10px 'Press Start 2P'";
    ctx.fillText("JUMP = SPACE / TAP", innerWidth/2, innerHeight/2 + 70);

    ctx.textAlign = "left";
  }

  function drawOverlay(textLines){
    ctx.fillStyle="rgba(0,0,0,0.82)";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";
    ctx.font="10px 'Press Start 2P'";
    let y = innerHeight/2 - 60;
    for (const line of textLines){
      ctx.fillText(line, innerWidth/2, y);
      y += 18;
    }
    ctx.font="9px 'Press Start 2P'";
    ctx.fillText("Press Space / Tap", innerWidth/2, y + 18);
    ctx.textAlign="left";
  }

  function draw(){
    if (mode === "title") { drawTitle(); return; }
    if (mode === "countdown") { drawCountdown(); return; }

    // playfield always visible in play/pause/gameover/ending
    drawPlayfield();
    drawHUD();
    drawPopupAndWhisper();

    if (mode === "pause"){
      drawOverlay(["PAUSED"]);
      return;
    }

    if (mode === "gameover"){
      drawOverlay([`You caught ${lastObstacleLabel}.`, "GAME OVER", ""]);
      return;
    }

    if (mode === "ending"){
      drawOverlay([
        "CONGRATULATIONS.",
        "YOU ARE NOW A SPIRITUAL BEING",
        "WHO HAD A HUMAN EXPERIENCE."
      ]);
      return;
    }
  }

  /* =========================
     MAIN LOOP
  ========================= */
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  // init
  resetRun();
  setMode("title");
  loop();

})();
</script>
</body>
</html>
