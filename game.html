<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Trudge the Road</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  html, body{
    margin:0; padding:0; height:100%;
    background:#000; overflow:hidden;
    font-family:"Press Start 2P", monospace;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  #pauseBtn{
    position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
    font-family:"Press Start 2P", monospace; font-size:10px;
    padding:10px 14px; background:#111; color:#fff;
    border:1px solid #444; border-radius:8px; opacity:.92; z-index:10;
    display:none;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<button id="pauseBtn">PAUSE</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize);
  resize();

  /* =========================
     SPRITE: runner.png
  ========================= */
  const runnerImg = new Image();
  runnerImg.src = "./runner.png";
  let runnerReady = false;
  runnerImg.onload = () => runnerReady = true;
  runnerImg.onerror = () => runnerReady = false;

  const RUNNER_FRAMES = 1; // set >1 if you later use a sprite sheet
  const RUNNER_FPS = 10;
  let runnerFrame = 0;
  let runnerTick = 0;

  /* =========================
     MODES
  ========================= */
  let mode = "title"; // title | countdown | play | pause | gameover | ending

  function setMode(m){
    mode = m;
    document.getElementById("pauseBtn").style.display =
      (mode === "play" || mode === "pause") ? "block" : "none";
  }

  /* =========================
     GAME FEEL / GOALS
  ========================= */
  const MAX_LIVES = 5;

  const LANE_COUNT = 3;
  const LANE_SNAP_SPEED = 0.36;

  // 2x-ish runner
  const player = {
    x: 140,
    y: 0,
    w: 68,
    h: 88,
    lane: 1,
    laneTarget: 1
  };

  // Base speed and ramp; "New Game+" increases via prestigeSpeedBoost
  const BASE_SPEED = 3.7;
  const MAX_SPEED  = 7.2;
  let prestige = 0;               // increments each time you beat Step 12
  let prestigeSpeedBoost = 0.0;   // derived from prestige

  // Spawning gaps (tuned for ~10 minutes to finish, depending on play)
  let obstacleGapPx = 420;
  let bonusGapPx = 950;

  // Step token pacing: roughly one step opportunity every ~35‚Äì60 seconds
  let stepCooldown = 0;         // frames until the next Step token can spawn
  let stepSpawnBias = 0;        // increases if you haven‚Äôt seen a step in a while

  // grace after hit
  let invuln = 0;

  /* =========================
     CONTENT
  ========================= */
  const obstaclesPool = [
    "Anger","Resentment","Fear","Self-pity","Anxiety","Guilt","Shame",
    "Ego","Overthinking","Self-obsession","Self-righteousness","Control",
    "People-pleasing","Comparison","Relationship drama","Family conflict",
    "Isolation","Unsaid resentment","Not speaking up","Old friends",
    "Work stress","Money worries","Time pressure","Social media","Home chaos","Traffic",
    "Complacency","Dishonesty","Not listening","Selective hearing",
    "Not asking for help","Emotional numbness","Avoidance","Confusion","Uncertainty",
    "Restless","Irritable","Discontent","Catastrophizing","Projection"
  ];

  // AA actions (still give you help / lives / calm)
  const bonusesPool = [
    { label:"Go to a meeting", type:"life" },
    { label:"Call a friend", type:"life" },
    { label:"Call your sponsor", type:"life" },
    { label:"Pray / pause", type:"slow" },
    { label:"Write it down", type:"clear" }
  ];

  // Step + principle (you can edit these anytime)
  const steps = [
    { n: 1, p: "HONESTY" },
    { n: 2, p: "HOPE" },
    { n: 3, p: "FAITH" },
    { n: 4, p: "COURAGE" },
    { n: 5, p: "INTEGRITY" },
    { n: 6, p: "WILLINGNESS" },
    { n: 7, p: "HUMILITY" },
    { n: 8, p: "BROTHERLY LOVE" },
    { n: 9, p: "DISCIPLINE" },
    { n:10, p: "PERSEVERANCE" },
    { n:11, p: "SPIRITUAL AWARENESS" },
    { n:12, p: "SERVICE" }
  ];

  const levelSayings = [
    "Keep coming back",
    "Easy does it",
    "Progress, not perfection",
    "One day at a time",
    "Keep it simple",
    "Stay in the middle"
  ];

  /* =========================
     STATE
  ========================= */
  let lives = MAX_LIVES;
  let lastObstacleLabel = "something";

  // Progress is now Steps collected in order
  let stepIndex = 0; // 0 means next is Step 1, ... 11 means next is Step 12

  // ‚Äúbig messages‚Äù
  let banner = null; // {kind,title,sub,t,ttl}
  let slowMo = 0;

  function makeBanner(kind, title, sub="", ttl=150){
    banner = { kind, title, sub, t:0, ttl };
    slowMo = (kind === "bad") ? 85 : 65;
  }

  // temporary effects
  let slowTimer = 0;
  let clearArmed = false;

  // objects
  const obstacles = []; // {x,y,w,h,label,lane,passed}
  const bonuses = [];   // {x,y,w,h,label,lane,type}
  const stepTokens = []; // {x,y,w,h,stepN,principle,lane}

  // title/countdown
  let titleTimer = 0;
  let countdownTimer = 0;
  let countdownValue = 3;

  /* =========================
     STARFIELD (ASCII-ish)
  ========================= */
  const stars = [];
  const STAR_CHARS = [".", ".", ".", "*", "+", "¬∑", "Àô"];
  function initStars(){
    stars.length = 0;
    const count = Math.min(220, Math.floor((innerWidth * innerHeight) / 7000));
    for (let i=0;i<count;i++){
      stars.push({
        x: Math.random() * innerWidth,
        y: Math.random() * innerHeight,
        z: 0.4 + Math.random() * 1.6, // parallax
        ch: STAR_CHARS[(Math.random()*STAR_CHARS.length)|0],
        tw: Math.random()*1000
      });
    }
  }
  initStars();
  addEventListener("resize", initStars);

  function drawStarfield(scrollSpeed){
    // move left with slight parallax
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "#fff";
    ctx.font = "10px 'Press Start 2P'";
    for (const s of stars){
      s.x -= scrollSpeed * 0.35 * s.z;
      s.tw += 1;
      if (s.x < -10) { s.x = innerWidth + 10; s.y = Math.random()*innerHeight; s.z = 0.4 + Math.random()*1.6; }

      // subtle twinkle
      const a = 0.35 + 0.35 * (0.5 + 0.5 * Math.sin((s.tw/35) + s.y*0.02));
      ctx.globalAlpha = a;

      // some stars are ASCII chars, some are dots
      if (s.ch === "." || s.ch === "¬∑" || s.ch === "Àô"){
        ctx.fillRect(s.x|0, s.y|0, 2, 2);
      } else {
        ctx.fillText(s.ch, s.x|0, s.y|0);
      }
    }
    ctx.globalAlpha = 1;
  }

  /* =========================
     HELPERS
  ========================= */
  function rand(arr){ return arr[(Math.random()*arr.length)|0]; }

  function laneYCenters(){
    const top = 190;
    const bottom = innerHeight - 160;
    const gap = (bottom - top) / (LANE_COUNT - 1);
    return [top, top + gap, bottom];
  }

  function sizeForLabel(label, minW, maxW, h){
    const extra = Math.min(360, Math.max(0, (label.length - 10) * 11));
    const w = Math.min(maxW, minW + extra);
    return { w, h };
  }

  function currentSpeed(){
    let s = BASE_SPEED + prestigeSpeedBoost;

    // ramp slowly as you get deeper into steps (so it feels like ‚Äúlevels‚Äù)
    s += stepIndex * 0.20;

    // also ramp a little by time/pressure (obstacles passed)
    s += Math.min(1.4, obstaclesPassed * 0.0025);

    s = Math.min(MAX_SPEED + prestigeSpeedBoost, s);

    if (slowTimer > 0) s *= 0.72;
    if (slowMo > 0) s *= 0.35;

    return s;
  }

  function resetRun(keepPrestige=true){
    lives = MAX_LIVES;
    lastObstacleLabel = "something";

    stepIndex = 0;

    obstacles.length = 0;
    bonuses.length = 0;
    stepTokens.length = 0;

    obstacleGapPx = 420;
    bonusGapPx = 950;

    slowTimer = 0;
    clearArmed = false;
    invuln = 0;

    banner = null;
    slowMo = 0;

    stepCooldown = 60 * 8; // ~8 seconds before step tokens can start
    stepSpawnBias = 0;

    obstaclesPassed = 0;

    player.lane = 1;
    player.laneTarget = 1;
    player.y = laneYCenters()[1] - player.h/2;

    if (!keepPrestige){
      prestige = 0;
      prestigeSpeedBoost = 0;
    }

    makeBanner("good", "STEP 1 ‚Äî HONESTY", "Gather steps in order.", 160);
  }

  function startCountdown(){
    resetRun(true);
    countdownValue = 3;
    countdownTimer = 0;
    setMode("countdown");
  }

  /* =========================
     INPUT: TAP = CHANGE LANE
  ========================= */
  function onTap(){
    if (mode === "title"){ startCountdown(); return; }
    if (mode === "gameover" || mode === "ending"){
      // Try again = start over, speed increases after winning
      setMode("title");
      titleTimer = 0;
      return;
    }
    if (mode !== "play") return;

    player.laneTarget = (player.laneTarget + 1) % LANE_COUNT;
  }

  addEventListener("keydown", e => { if (e.code === "Space") onTap(); });
  addEventListener("mousedown", onTap, {passive:true});
  addEventListener("touchstart", onTap, {passive:true});

  document.getElementById("pauseBtn").onclick = () => {
    if (mode === "play") setMode("pause");
    else if (mode === "pause") setMode("play");
  };

  /* =========================
     SPAWN
  ========================= */
  function spawnObstacle(){
    const label = rand(obstaclesPool);
    const lane = (Math.random() * LANE_COUNT) | 0;
    const lanes = laneYCenters();
    const { w, h } = sizeForLabel(label, 220, 540, 46);

    obstacles.push({
      x: innerWidth + 90,
      y: lanes[lane] - h/2,
      w, h,
      label,
      lane,
      passed:false
    });

    // occasional double trouble
    if (Math.random() < 0.20){
      const lane2 = (lane + 1 + ((Math.random()*2)|0)) % LANE_COUNT;
      const label2 = rand(obstaclesPool);
      const { w: w2, h: h2 } = sizeForLabel(label2, 210, 520, 44);
      obstacles.push({
        x: innerWidth + 90 + 280,
        y: lanes[lane2] - h2/2,
        w: w2, h: h2,
        label: label2,
        lane: lane2,
        passed:false
      });
    }
  }

  function spawnBonus(){
    const b = rand(bonusesPool);
    const lanes = laneYCenters();
    const r = Math.random();
    const lane = r < 0.55 ? 1 : (r < 0.78 ? 0 : 2);

    const { w, h } = sizeForLabel(b.label, 280, 580, 42);

    bonuses.push({
      x: innerWidth + 90,
      y: lanes[lane] - h/2,
      w, h,
      label: b.label,
      lane,
      type: b.type
    });
  }

  function spawnStepToken(){
    // Spawn the NEXT required step (in order) as a pink cloud token.
    if (stepIndex >= 12) return;

    const next = steps[stepIndex];
    const label = `STEP ${next.n} ‚Äî ${next.p}`;

    const lanes = laneYCenters();
    const lane = (Math.random() * LANE_COUNT) | 0;

    const { w, h } = sizeForLabel(label, 360, 760, 52);

    stepTokens.push({
      x: innerWidth + 110,
      y: lanes[lane] - h/2,
      w, h,
      stepN: next.n,
      principle: next.p,
      lane,
      label
    });
  }

  /* =========================
     COLLISION
  ========================= */
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  /* =========================
     DRAW STYLES
  ========================= */
  function drawHeaderTitle(){
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    ctx.fillRect(0, 0, innerWidth, 62);

    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.beginPath();
    ctx.moveTo(0, 62);
    ctx.lineTo(innerWidth, 62);
    ctx.stroke();

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "14px 'Press Start 2P'";
    ctx.fillText("TRUDGE THE ROAD", innerWidth/2, 38);

    // Step progress (clear, obvious)
    const stepText = `STEP ${Math.min(12, stepIndex+1)} / 12`;
    ctx.font = "10px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText(stepText, 12, 86);

    // hint the objective briefly
    ctx.textAlign = "right";
    ctx.fillText("Gather steps. Avoid traps.", innerWidth - 12, 86);

    ctx.textAlign = "left";
    ctx.globalAlpha = 1;
  }

  function drawLanes(){
    const lanes = laneYCenters();
    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = "#333";
    for (let i = 0; i < lanes.length; i++){
      ctx.beginPath();
      ctx.moveTo(0, lanes[i]);
      ctx.lineTo(innerWidth, lanes[i]);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawDangerObstacle(o){
    const x=o.x, y=o.y, w=o.w, h=o.h;

    // red aura
    ctx.fillStyle = "rgba(255,0,0,0.12)";
    ctx.fillRect(x-8, y-6, w+16, h+12);

    // spiky top edge
    ctx.fillStyle = "#0b0b0b";
    ctx.strokeStyle = "rgba(255,80,80,0.9)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    const spikes = 10;
    const step = w / spikes;
    ctx.moveTo(x, y+h);
    for (let i=0;i<=spikes;i++){
      const px = x + i*step;
      const py = (i%2===0) ? y : (y + 12);
      ctx.lineTo(px, py);
    }
    ctx.lineTo(x+w, y+h);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.lineWidth = 1;

    // label
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(o.label.toUpperCase(), x + w/2, y + h/2 + 8);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  // More ‚Äúcloudy‚Äù pink cloud: overlapping puffs + outline + sparkle dots
  function drawPinkCloud(x, y, w, h, alpha=1){
    const cx = x + w/2;
    const cy = y + h/2;

    // glow halo
    ctx.globalAlpha = 0.16 * alpha;
    ctx.fillStyle = "rgba(255,105,180,1)";
    ctx.fillRect(x-18, y-16, w+36, h+32);

    // main puffs
    ctx.globalAlpha = 0.34 * alpha;
    ctx.fillStyle = "rgba(255,105,180,1)";
    const puffCount = 14;
    for (let i=0;i<puffCount;i++){
      const px = cx + (Math.random()*w*0.55 - w*0.275);
      const py = cy + (Math.random()*h*0.55 - h*0.275);
      const r  = 18 + Math.random()*18;
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI*2);
      ctx.fill();
    }

    // bright inner layer
    ctx.globalAlpha = 0.20 * alpha;
    ctx.fillStyle = "rgba(255,200,225,1)";
    for (let i=0;i<8;i++){
      const px = cx + (Math.random()*w*0.38 - w*0.19);
      const py = cy + (Math.random()*h*0.38 - h*0.19);
      const r  = 14 + Math.random()*12;
      ctx.beginPath();
      ctx.arc(px, py, r, 0, Math.PI*2);
      ctx.fill();
    }

    // outline to ‚Äúread‚Äù as a thing
    ctx.globalAlpha = 0.95 * alpha;
    ctx.strokeStyle = "rgba(255,180,220,0.95)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
    ctx.lineWidth = 1;

    // sparkles
    ctx.globalAlpha = 0.7 * alpha;
    ctx.fillStyle = "rgba(255,240,250,1)";
    for (let i=0;i<10;i++){
      const sx = x + Math.random()*w;
      const sy = y + Math.random()*h;
      ctx.fillRect(sx|0, sy|0, 2, 2);
    }

    ctx.globalAlpha = 1;
  }

  function drawBonus(b){
    drawPinkCloud(b.x, b.y, b.w, b.h, 1);
    ctx.font = "12px 'Press Start 2P'";
    ctx.fillStyle = "rgba(255,245,250,1)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(b.label.toUpperCase(), b.x + b.w/2, b.y + b.h/2 + 2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  function drawStepToken(tk){
    drawPinkCloud(tk.x, tk.y, tk.w, tk.h, 1);

    // Make step token feel ‚Äúspecial‚Äù
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.strokeRect(tk.x-4, tk.y-4, tk.w+8, tk.h+8);

    ctx.font = "13px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(tk.label.toUpperCase(), tk.x + tk.w/2, tk.y + tk.h/2 + 2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
  }

  function drawRunner(){
    // optional sprite-sheet animation
    if (RUNNER_FRAMES > 1 && runnerReady && mode === "play"){
      runnerTick++;
      const frameEvery = Math.max(1, Math.floor(60 / RUNNER_FPS));
      if (runnerTick % frameEvery === 0) runnerFrame = (runnerFrame + 1) % RUNNER_FRAMES;
    }

    const x = player.x, y = player.y, w = player.w, h = player.h;

    if (!runnerReady){
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, w, h);
      return;
    }

    const imgW = runnerImg.width;
    const imgH = runnerImg.height;
    let sx=0, sy=0, sw=imgW, sh=imgH;
    if (RUNNER_FRAMES > 1){
      sw = Math.floor(imgW / RUNNER_FRAMES);
      sx = sw * runnerFrame;
    }

    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(runnerImg, sx, sy, sw, sh, x, y, w, h);
  }

  function drawLivesHUD(){
    const startX = 12, y = 96;
    const sizeW = 16, sizeH = 20, gap = 6;

    for (let i = 0; i < MAX_LIVES; i++){
      const x = startX + i * (sizeW + gap);
      if (i < lives){
        if (runnerReady){
          const imgW = runnerImg.width, imgH = runnerImg.height;
          let sx=0, sy=0, sw=imgW, sh=imgH;
          if (RUNNER_FRAMES > 1){
            sw = Math.floor(imgW / RUNNER_FRAMES);
            sx = 0;
          }
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(runnerImg, sx, sy, sw, sh, x, y, sizeW, sizeH);
        } else {
          ctx.font = "16px 'Press Start 2P'";
          ctx.fillStyle = "#fff";
          ctx.fillText("üßç", x, y+16);
        }
      } else {
        ctx.strokeStyle = "#333";
        ctx.strokeRect(x, y, sizeW, sizeH);
      }
    }
  }

  function drawBanner(){
    if (!banner) return;

    banner.t++;
    const t = banner.t;
    const ttl = banner.ttl;

    const fadeIn = Math.min(1, t / 18);
    const fadeOut = Math.min(1, (ttl - t) / 18);
    const alpha = Math.max(0, Math.min(1, Math.min(fadeIn, fadeOut)));

    ctx.globalAlpha = 0.92 * alpha;

    const boxW = Math.min(innerWidth - 40, 920);
    const boxH = 132;
    const bx = (innerWidth - boxW)/2;
    const by = 120;

    ctx.fillStyle =
      (banner.kind === "bad") ? "rgba(70,0,0,0.78)" :
      (banner.kind === "good") ? "rgba(0,40,0,0.72)" :
      "rgba(0,0,0,0.72)";
    ctx.fillRect(bx, by, boxW, boxH);

    ctx.strokeStyle =
      (banner.kind === "bad") ? "rgba(255,80,80,0.88)" :
      (banner.kind === "good") ? "rgba(120,255,140,0.82)" :
      "rgba(255,255,255,0.18)";
    ctx.lineWidth = 2;
    ctx.strokeRect(bx, by, boxW, boxH);
    ctx.lineWidth = 1;

    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";

    ctx.font = "16px 'Press Start 2P'";
    ctx.fillText(banner.title, innerWidth/2, by + 52);

    if (banner.sub){
      ctx.font = "12px 'Press Start 2P'";
      ctx.fillText(banner.sub, innerWidth/2, by + 92);
    }

    ctx.textAlign = "left";
    ctx.globalAlpha = 1;

    if (banner.t >= banner.ttl) banner = null;
  }

  function drawOverlay(lines){
    ctx.fillStyle="rgba(0,0,0,0.86)";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";
    ctx.font="11px 'Press Start 2P'";
    let y = innerHeight/2 - 90;
    for (const line of lines){
      ctx.fillText(line, innerWidth/2, y);
      y += 22;
    }
    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("Try again", innerWidth/2, y + 30);
    ctx.textAlign="left";
  }

  /* =========================
     UPDATE LOOP
  ========================= */
  let obstaclesPassed = 0;

  function updateTitle(){
    titleTimer++;
  }

  function updateCountdown(){
    countdownTimer++;
    if (countdownTimer % 60 === 0){
      countdownValue--;
      if (countdownValue < 0) setMode("play");
    }
  }

  function updatePlay(){
    if (invuln > 0) invuln--;
    if (slowTimer > 0) slowTimer--;
    if (slowMo > 0) slowMo--;

    // Smooth slide to target lane
    const lanes = laneYCenters();
    const targetY = lanes[player.laneTarget] - player.h/2;
    const dy = targetY - player.y;
    player.y += dy * LANE_SNAP_SPEED;
    if (Math.abs(dy) < 1.0){
      player.y = targetY;
      player.lane = player.laneTarget;
    }

    const spd = currentSpeed();

    // Step spawn pacing
    if (stepCooldown > 0) stepCooldown--;
    else stepSpawnBias += 1;

    // Move objects
    for (const o of obstacles) o.x -= spd;
    for (const b of bonuses) b.x -= spd;
    for (const s of stepTokens) s.x -= spd;

    // clear effect: clears the next obstacle in your lane
    if (clearArmed){
      const next = obstacles.find(o => o.x > player.x && o.x < player.x + 460 && o.lane === player.lane);
      if (next){
        next.x = -9999;
        clearArmed = false;
        makeBanner("good", "WRITE IT DOWN", "Cleared one trap.", 150);
      }
    }

    // Player hitbox (tight but fair)
    const rx = player.x + 14;
    const ry = player.y + 10;
    const rw = player.w - 26;
    const rh = player.h - 18;

    // Obstacle collisions (same lane)
    for (const o of obstacles){
      if (o.lane !== player.lane) continue;

      const ox = o.x + 16;
      const oy = o.y + 10;
      const ow = Math.max(2, o.w - 32);
      const oh = Math.max(2, o.h - 18);

      if (invuln === 0 && aabb(rx, ry, rw, rh, ox, oy, ow, oh)){
        lives--;
        lastObstacleLabel = o.label;
        invuln = 90;
        o.x = -9999;

        makeBanner("bad", `YOU CAUGHT: ${lastObstacleLabel.toUpperCase()}`, "-1 LIFE", 170);

        if (lives <= 0){
          setMode("gameover");
          return;
        }
      }

      // passed count drives speed ramp
      if (!o.passed && (o.x + o.w) < player.x){
        o.passed = true;
        obstaclesPassed++;

        // occasionally remind them what to do
        if (Math.random() < 0.012 && !banner){
          makeBanner("good", rand(levelSayings).toUpperCase(), "", 140);
        }
      }
    }

    // Bonus collisions (same lane)
    for (const b of bonuses){
      if (b.lane !== player.lane) continue;

      const bx = b.x + 16;
      const by = b.y + 10;
      const bw = Math.max(2, b.w - 32);
      const bh = Math.max(2, b.h - 18);

      if (aabb(rx, ry, rw, rh, bx, by, bw, bh)){
        if (b.type === "life"){
          const before = lives;
          lives = Math.min(MAX_LIVES, lives + 1);
          makeBanner("good", b.label.toUpperCase(), (lives>before ? "+1 LIFE" : "LIVES FULL"), 170);
        } else if (b.type === "slow"){
          slowTimer = 280;
          makeBanner("good", b.label.toUpperCase(), "SLOWING DOWN.", 160);
        } else if (b.type === "clear"){
          clearArmed = true;
          makeBanner("good", b.label.toUpperCase(), "NEXT TRAP CLEARS.", 160);
        }
        b.x = -9999;
      }
    }

    // Step token collisions (same lane)
    for (const s of stepTokens){
      if (s.lane !== player.lane) continue;

      const sx = s.x + 18;
      const sy = s.y + 12;
      const sw = Math.max(2, s.w - 36);
      const sh = Math.max(2, s.h - 22);

      if (aabb(rx, ry, rw, rh, sx, sy, sw, sh)){
        // This token is always the NEXT step (spawned that way), so advance.
        stepIndex++;
        s.x = -9999;

        if (stepIndex <= 12){
          if (stepIndex < 12){
            const next = steps[stepIndex];
            makeBanner("good", `STEP ${steps[stepIndex-1].n} ‚Äî ${steps[stepIndex-1].p}`, "Nice. Keep moving.", 180);
            // set cooldown until the next step token appears
            stepCooldown = 60 * (28 + (Math.random()*18|0)); // 28‚Äì46 seconds
            stepSpawnBias = 0;
          } else {
            // Completed Step 12
            setMode("ending");
            return;
          }
        }
      }
    }

    // Cleanup offscreen
    for (let i = obstacles.length - 1; i >= 0; i--){
      if (obstacles[i].x < -1200) obstacles.splice(i, 1);
    }
    for (let i = bonuses.length - 1; i >= 0; i--){
      if (bonuses[i].x < -1200) bonuses.splice(i, 1);
    }
    for (let i = stepTokens.length - 1; i >= 0; i--){
      if (stepTokens[i].x < -1400) stepTokens.splice(i, 1);
    }

    // Spawn spacing
    obstacleGapPx -= spd;
    bonusGapPx -= spd;

    if (obstacleGapPx <= 0){
      spawnObstacle();
      obstacleGapPx = 420 + ((Math.random() * 260) | 0); // 420‚Äì680px
    }

    if (bonusGapPx <= 0 && Math.random() < 0.42){
      spawnBonus();
      bonusGapPx = 980 + ((Math.random() * 560) | 0); // 980‚Äì1540px
    }

    // Step token spawn logic:
    // - only if you haven't already spawned one recently
    // - only if there isn't already a step token on screen
    // - chance increases the longer it‚Äôs been since last step
    if (stepIndex < 12 && stepTokens.length === 0 && stepCooldown <= 0){
      const chance = Math.min(0.020 + stepSpawnBias * 0.00008, 0.08); // grows up to 8%
      if (Math.random() < chance){
        spawnStepToken();
        // after spawning, prevent immediate respawns
        stepCooldown = 60 * (18 + (Math.random()*12|0)); // 18‚Äì30 seconds minimum
        stepSpawnBias = 0;

        // subtle banner to make ‚Äúlevel progression‚Äù obvious
        const next = steps[stepIndex];
        makeBanner("status", `NEXT: STEP ${next.n} ‚Äî ${next.p}`, "Find the pink cloud.", 160);
      }
    }
  }

  function update(){
    if (mode === "title") return updateTitle();
    if (mode === "countdown") return updateCountdown();
    if (mode === "pause" || mode === "gameover" || mode === "ending") return;
    if (mode === "play") return updatePlay();
  }

  /* =========================
     DRAW SCREENS
  ========================= */
  function drawTitle(){
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    drawStarfield(0.6);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";

    ctx.font="28px 'Press Start 2P'";
    ctx.fillText("TRUDGE", innerWidth/2, innerHeight/2 - 110);
    ctx.fillText("THE ROAD", innerWidth/2, innerHeight/2 - 70);

    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("avoid the traps, gather the pink clouds", innerWidth/2, innerHeight/2 - 22);

    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("Rocketed into the 4th dimension in...", innerWidth/2, innerHeight/2 + 24);

    const blink = ((titleTimer/18)|0) % 2 === 0;
    if (blink){
      ctx.fillText("PRESS SPACE / TAP", innerWidth/2, innerHeight/2 + 78);
    }

    ctx.font="9px 'Press Start 2P'";
    ctx.fillText("TAP = CHANGE LANES", innerWidth/2, innerHeight/2 + 108);

    ctx.textAlign="left";
  }

  function drawCountdown(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    drawStarfield(1.0);

    ctx.fillStyle="#fff";
    ctx.textAlign="center";

    ctx.font="14px 'Press Start 2P'";
    ctx.fillText("ROCKETED INTO THE 4TH DIMENSION IN...", innerWidth/2, innerHeight/2 - 120);

    const show = (countdownValue >= 1) ? String(countdownValue) : (countdownValue === 0 ? "GO!" : "");
    ctx.font="56px 'Press Start 2P'";
    ctx.fillText(show, innerWidth/2, innerHeight/2 - 20);

    ctx.font="10px 'Press Start 2P'";
    ctx.fillText("SPACE/TAP = CHANGE LANES", innerWidth/2, innerHeight/2 + 80);

    ctx.textAlign="left";
  }

  function drawPlayfield(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // scrolling background
    drawStarfield(currentSpeed());

    drawHeaderTitle();
    drawLanes();

    // obstacles (danger)
    for (const o of obstacles) drawDangerObstacle(o);

    // bonuses (pink clouds)
    for (const b of bonuses) drawBonus(b);

    // step tokens (special pink clouds)
    for (const s of stepTokens) drawStepToken(s);

    // runner
    drawRunner();

    // invuln hint
    if (invuln > 0){
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "#fff";
      ctx.fillRect(player.x - 10, player.y - 10, player.w + 20, player.h + 20);
      ctx.globalAlpha = 1;
    }

    drawLivesHUD();
    drawBanner();
  }

  function drawGameOver(){
    drawOverlay([
      `YOU CAUGHT: ${lastObstacleLabel.toUpperCase()}`,
      "GAME OVER",
      "",
      "Try again ‚Äî or don‚Äôt.",
      "We‚Äôll be here."
    ]);
  }

  function drawEnding(){
    // Prestige bump happens when you press to go back to title and start again
    drawOverlay([
      "YOU GOT THROUGH THE 12 STEPS.",
      "NOW DO IT AGAIN.",
      "",
      "NEXT RUN = FASTER ROAD."
    ]);
  }

  function drawPause(){
    drawOverlay(["PAUSED"]);
  }

  function draw(){
    if (mode === "title") return drawTitle();
    if (mode === "countdown") return drawCountdown();

    drawPlayfield();

    if (mode === "pause") return drawPause();
    if (mode === "gameover") return drawGameOver();
    if (mode === "ending") return drawEnding();
  }

  /* =========================
     ENDING / TRY AGAIN BEHAVIOR
  ========================= */
  function handleTryAgainFromEnding(){
    // called implicitly when you tap on title next time;
    // we apply prestige boost once you complete a run.
    prestige++;
    prestigeSpeedBoost = Math.min(2.0, prestige * 0.30); // +0.30 per win, caps at +2.0
  }

  // hook into mode changes: when leaving ending to title, apply prestige
  const _setMode = setMode;
  setMode = (m) => {
    if (mode === "ending" && m === "title"){
      handleTryAgainFromEnding();
    }
    _setMode(m);
  };

  /* =========================
     MAIN LOOP
  ========================= */
  resetRun(true);
  setMode("title");

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();

})();
</script>
</body>
</html>
