<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Trudge the Road</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  html, body{
    margin:0;
    padding:0;
    background:#000;
    overflow:hidden;
    height:100%;
    font-family:"Press Start 2P", monospace;
  }
  canvas{ display:block; width:100vw; height:100vh; }
  #pauseBtn{
    position:fixed;
    bottom:10px;
    left:50%;
    transform:translateX(-50%);
    font-family:"Press Start 2P", monospace;
    font-size:10px;
    padding:10px 14px;
    background:#111;
    color:#fff;
    border:1px solid #444;
    border-radius:8px;
    opacity:.92;
    z-index:10;
  }
</style>
</head>

<body>
<canvas id="game"></canvas>
<button id="pauseBtn">PAUSE</button>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize);
  resize();

  /* =========================
     STATE
  ========================= */
  let mode = "play"; // play | pause | gameover | ending
  let lives = 5;
  let coins = 1; // 24-hour coin
  let obstaclesCleared = 0;

  let lastObstacleLabel = "something";
  let streak = 0;
  let closeCallCooldown = 0;
  let slowTimer = 0;
  let clearNext = false;
  let popup = null;   // {text, sub, t, ttl}
  let whisper = null; // {text, t, ttl}
  let lastStatusName = "";

  // controlled spawns (prevents unfair clusters)
  let obstacleCooldown = 0;
  let bonusCooldown = 0;

  /* =========================
     CONSTANTS (EASIER)
  ========================= */
  const MAX_LIVES = 5;
  const END_COINS = 101;

  // Make it playable:
  const BASE_SPEED = 3.2;   // slower
  const MAX_SPEED  = 5.2;   // calmer top speed
  const GRAVITY    = 0.75;
  const JUMP_VY    = -16.5; // higher jump

  const GROUND_H = 44;
  const GROUND_Y = () => (innerHeight - GROUND_H);

  /* =========================
     PLAYER (simple 8-bit-ish)
  ========================= */
  const player = {
    x: 90,
    y: 0,
    w: 18,
    h: 34,
    vy: 0,
    onGround: false
  };

  /* =========================
     POOLS
  ========================= */
  const obstaclesPool = [
    { e:"ðŸ˜¡", l:"Anger" },
    { e:"ðŸ˜¤", l:"Resentment" },
    { e:"ðŸ˜±", l:"Fear" },
    { e:"ðŸ˜”", l:"Self-pity" },
    { e:"ðŸ˜¬", l:"Anxiety" },
    { e:"ðŸ˜ž", l:"Guilt" },
    { e:"ðŸ˜¶", l:"Shame" },
    { e:"ðŸ¤¡", l:"Ego" },
    { e:"ðŸ§ ", l:"Overthinking" },
    { e:"ðŸªž", l:"Self-obsession" },
    { e:"ðŸ—£ï¸", l:"Self-righteousness" },
    { e:"ðŸ§©", l:"Control" },
    { e:"ðŸŽ­", l:"People-pleasing" },
    { e:"ðŸ†", l:"Comparison" },
    { e:"ðŸ’”", l:"Relationship drama" },
    { e:"ðŸ‘¨â€ðŸ‘©â€ðŸ‘§", l:"Family conflict" },
    { e:"ðŸ§", l:"Isolation" },
    { e:"ðŸ—¯ï¸", l:"Unsaid resentment" },
    { e:"ðŸ¤", l:"Not speaking up" },
    { e:"ðŸ§‘â€ðŸ¤â€ðŸ§‘", l:"Old friends" },
    { e:"ðŸ’¼", l:"Work stress" },
    { e:"ðŸ’¸", l:"Money worries" },
    { e:"ðŸ•°ï¸", l:"Time pressure" },
    { e:"ðŸ“±", l:"Social media" },
    { e:"ðŸ ", l:"Home chaos" },
    { e:"ðŸš—", l:"Traffic" },
    { e:"ðŸ’¤", l:"Complacency" },
    { e:"ðŸ¤¥", l:"Dishonesty" },
    { e:"ðŸ™‰", l:"Not listening" },
    { e:"ðŸ§", l:"Selective hearing" },
    { e:"ðŸ›‘", l:"Not asking for help" },
    { e:"ðŸ§Š", l:"Emotional numbness" },
    { e:"ðŸ•³ï¸", l:"Avoidance" },
    { e:"ðŸŒ«ï¸", l:"Confusion" },
    { e:"â“", l:"Uncertainty" }
  ];

  const bonusesPool = [
    { e:"ðŸ“ž", l:"Call a friend", type:"life" },
    { e:"ðŸ¤", l:"Go to a meeting", type:"life" },
    { e:"ðŸ‘¥", l:"Talk to someone", type:"life" },
    { e:"ðŸ§Ž", l:"Pause", type:"slow" },
    { e:"ðŸ“", l:"Write it down", type:"clear" }
  ];

  const coinSayings = [
    "Keep coming back",
    "Just for today",
    "Progress, not perfection",
    "Easy does it",
    "One day at a time",
    "Keep it simple",
    "Let go",
    "Stay in the middle",
    "This too shall pass"
  ];

  const quietHelps = [
    "Breathe.",
    "Slow down.",
    "Call someone.",
    "You donâ€™t have to solve this.",
    "Just do the next right thing.",
    "Donâ€™t do it alone."
  ];

  const rareEasterEggs = [
    "Youâ€™re doing better than you think.",
    "Welcome back.",
    "This isnâ€™t your first restart."
  ];

  const statusTable = [
    { c: 1,  name:"Newcomer",              sub:"Still showing up." },
    { c: 3,  name:"Keep Coming Back",      sub:"It works if we work it." },
    { c: 10, name:"Old Timer",             sub:"Still figuring it out." },
    { c: 25, name:"Grizzled Sober Human",  sub:"Less drama. More truth." },
    { c: 50, name:"Spiritual Janitor",     sub:"Quiet work. No applause." },
    { c: 75, name:"Elder of the Folding Chairs", sub:"Listening is a superpower." },
    { c: 100,name:"Almost There",          sub:"Donâ€™t rush the miracle." }
  ];

  /* =========================
     OBJECTS
  ========================= */
  const obstacles = [];
  const bonuses = [];

  function rand(arr){ return arr[(Math.random() * arr.length) | 0]; }

  function makePopup(text, sub="", ttl=110){ popup = { text, sub, t:0, ttl }; }
  function makeWhisper(text, ttl=90){ whisper = { text, t:0, ttl }; }

  function maybeStatusUpdate(){
    let chosen = null;
    for (const s of statusTable) if (coins >= s.c) chosen = s;
    if (chosen && chosen.name !== lastStatusName){
      lastStatusName = chosen.name;
      makePopup(chosen.name, chosen.sub, 125);
    }
  }

  function onCoinGained(){
    if (Math.random() < 0.85) makePopup(rand(coinSayings), "", 90);
    if (Math.random() < 0.01) makePopup(rand(rareEasterEggs), "", 120);
    maybeStatusUpdate();
  }

  function resetGame(){
    mode = "play";
    lives = 5;
    coins = 1;
    obstaclesCleared = 0;
    lastObstacleLabel = "something";
    streak = 0;
    closeCallCooldown = 0;
    slowTimer = 0;
    clearNext = false;
    popup = null;
    whisper = null;
    lastStatusName = "";
    obstacles.length = 0;
    bonuses.length = 0;
    obstacleCooldown = 0;
    bonusCooldown = 0;
    player.y = GROUND_Y() - player.h;
    player.vy = 0;
    player.onGround = true;
    maybeStatusUpdate();
  }

  /* =========================
     INPUT
  ========================= */
  function jump(){
    if (mode !== "play") return;
    if (player.onGround){
      player.vy = JUMP_VY;
      player.onGround = false;
    }
  }

  addEventListener("keydown", e => {
    if (e.code === "Space"){
      if (mode === "gameover" || mode === "ending") resetGame();
      else jump();
    }
  });
  addEventListener("mousedown", () => {
    if (mode === "gameover" || mode === "ending") resetGame();
    else jump();
  }, {passive:true});
  addEventListener("touchstart", () => {
    if (mode === "gameover" || mode === "ending") resetGame();
    else jump();
  }, {passive:true});

  /* =========================
     PAUSE BUTTON
  ========================= */
  const pauseBtn = document.getElementById("pauseBtn");
  pauseBtn.onclick = () => {
    if (mode === "play") mode = "pause";
    else if (mode === "pause") mode = "play";
  };

  /* =========================
     SPAWNERS (SPACED OUT)
  ========================= */
  function spawnObstacle(){
    const o = rand(obstaclesPool);
    obstacles.push({
      x: innerWidth + 30,
      y: GROUND_Y() - 26,  // emoji baseline
      w: 34, h: 34,
      e: o.e, l: o.l,
      passed:false,
      closeChecked:false
    });
  }

  function spawnBonus(){
    const b = rand(bonusesPool);
    bonuses.push({
      x: innerWidth + 30,
      y: GROUND_Y() - 110,
      w: 34, h: 34,
      e: b.e, l: b.l, type: b.type
    });
  }

  /* =========================
     COLLISION
  ========================= */
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  /* =========================
     GAME FEEL
  ========================= */
  function currentSpeed(){
    let s = BASE_SPEED + (coins * 0.015) + (Math.floor(obstaclesCleared/40) * 0.10);
    s = Math.min(MAX_SPEED, s);
    if (slowTimer > 0) s *= 0.65;
    return s;
  }

  /* =========================
     UPDATE
  ========================= */
  function update(){
    if (mode !== "play") return;

    // ending
    if (coins >= END_COINS){
      mode = "ending";
      return;
    }

    // timers
    if (closeCallCooldown > 0) closeCallCooldown--;
    if (slowTimer > 0) slowTimer--;
    if (obstacleCooldown > 0) obstacleCooldown--;
    if (bonusCooldown > 0) bonusCooldown--;

    if (popup){
      popup.t++;
      if (popup.t > popup.ttl) popup = null;
    }
    if (whisper){
      whisper.t++;
      if (whisper.t > whisper.ttl) whisper = null;
    }

    // physics
    player.vy += GRAVITY;
    player.y += player.vy;

    const groundTop = GROUND_Y();
    if (player.y + player.h >= groundTop){
      player.y = groundTop - player.h;
      player.vy = 0;
      player.onGround = true;
    }

    const spd = currentSpeed();

    // move
    for (const o of obstacles) o.x -= spd;
    for (const b of bonuses) b.x -= spd;

    // clear-next effect
    if (clearNext){
      const target = obstacles.find(o => o.x > player.x && o.x < player.x + 240);
      if (target){
        target.x = -9999;
        clearNext = false;
        makeWhisper("Cleared one.", 70);
      }
    }

    // obstacles logic
    for (const o of obstacles){
      const hit = aabb(player.x, player.y, player.w, player.h, o.x+6, o.y+6, o.w-12, o.h-12);
      if (hit){
        lives--;
        lastObstacleLabel = o.l;
        streak = 0;
        o.x = -9999;

        if (lives <= 0){
          mode = "gameover";
          return;
        }
      }

      // close call (rare)
      if (!o.closeChecked && closeCallCooldown === 0){
        const nearX = Math.abs((o.x + o.w/2) - (player.x + player.w/2)) < 22;
        const nearY = (o.y < player.y + player.h) && (o.y + o.h > player.y + player.h - 10);
        if (nearX && nearY && !hit){
          o.closeChecked = true;
          closeCallCooldown = 110;
          if (Math.random() < 0.55) makeWhisper("That was close.", 80);
        }
      }

      // passed
      if (!o.passed && o.x + o.w < player.x){
        o.passed = true;
        obstaclesCleared++;
        streak++;

        if (obstaclesCleared % 12 === 0){
          coins++;
          onCoinGained();
        }

        if (streak === 25) makePopup("Progress, not perfection.", "", 115);

        if (!whisper && Math.random() < 0.012){
          makeWhisper(rand(quietHelps), 85);
        }
      }
    }

    // bonuses
    for (const b of bonuses){
      const got = aabb(player.x, player.y, player.w, player.h, b.x+6, b.y+6, b.w-12, b.h-12);
      if (got){
        if (b.type === "life"){
          const before = lives;
          lives = Math.min(MAX_LIVES, lives + 1);
          if (lives > before) makePopup(b.l, "+1 life", 90);
          else makePopup(b.l, "Already full.", 80);
        } else if (b.type === "slow"){
          slowTimer = 200;
          makePopup(b.l, "Quiet for a second.", 95);
        } else if (b.type === "clear"){
          clearNext = true;
          makePopup(b.l, "One obstacle gets cleared.", 100);
        }
        b.x = -9999;
      }
    }

    // cleanup
    for (let i = obstacles.length - 1; i >= 0; i--){
      if (obstacles[i].x < -160) obstacles.splice(i, 1);
    }
    for (let i = bonuses.length - 1; i >= 0; i--){
      if (bonuses[i].x < -160) bonuses.splice(i, 1);
    }

    // spawning with spacing (key fix)
    // Guarantee minimum gap by using cooldown frames.
    // Slightly reduces cooldown as coins rise, but stays fair.
    const minGap = Math.max(38, 54 - Math.floor(coins / 10) * 2); // frames
    const minBonusGap = 140;

    if (obstacleCooldown <= 0){
      spawnObstacle();
      obstacleCooldown = minGap + (Math.random()*18|0);
    }

    if (bonusCooldown <= 0 && Math.random() < 0.35){
      spawnBonus();
      bonusCooldown = minBonusGap + (Math.random()*60|0);
    }
  }

  /* =========================
     DRAW HELPERS
  ========================= */
  function drawTextCenter(lines, yStart, lineH){
    ctx.textAlign = "center";
    for (let i = 0; i < lines.length; i++){
      ctx.fillText(lines[i], innerWidth/2, yStart + i*lineH);
    }
    ctx.textAlign = "left";
  }

  function drawButtonCentered(label, y, w=260, h=50){
    const x = innerWidth/2 - w/2;
    ctx.fillStyle = "#111";
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = "#444";
    ctx.strokeRect(x, y, w, h);

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.fillText(label, innerWidth/2, y + h/2 + 6);
    ctx.textAlign = "left";

    return {x, y, w, h};
  }

  function drawLabelBackplate(text, x, y){
    // draw a subtle dark box behind text so itâ€™s always readable
    ctx.font = "10px 'Press Start 2P'";
    const padX = 6, padY = 4;
    const w = ctx.measureText(text).width + padX*2;
    const h = 14;

    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(x - padX, y - h + padY, w, h);

    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.strokeRect(x - padX, y - h + padY, w, h);

    ctx.fillStyle = "#fff";
    ctx.fillText(text, x, y);
  }

  /* =========================
     DRAW
  ========================= */
  let overlayButtons = { resumeBtn:null, quitBtn:null, tryAgainBtn:null };

  function draw(){
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // ground
    ctx.fillStyle = "#222";
    ctx.fillRect(0, GROUND_Y(), innerWidth, GROUND_H);

    // ground detail
    ctx.fillStyle = "#2f2f2f";
    for (let i = 0; i < innerWidth; i += 28){
      ctx.fillRect(i, GROUND_Y()+10, 10, 2);
    }

    // player
    ctx.fillStyle = "#fff";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x + 4, player.y - 8, 10, 8);

    // obstacles: emoji + BIG WORDS (visible)
    for (const o of obstacles){
      // emoji
      ctx.font = "26px serif";
      ctx.fillStyle = "#fff";
      ctx.fillText(o.e, o.x, o.y + 22);

      // label ABOVE the emoji (so it won't get lost in ground)
      const label = o.l.toUpperCase();
      drawLabelBackplate(label, o.x - 4, o.y - 8);
    }

    // bonuses: emoji + words
    for (const b of bonuses){
      ctx.font = "26px serif";
      ctx.fillStyle = "#fff";
      ctx.fillText(b.e, b.x, b.y + 22);

      const label = b.l.toUpperCase();
      drawLabelBackplate(label, b.x - 4, b.y - 8);
    }

    // HUD
    ctx.font = "10px 'Press Start 2P'";
    ctx.fillStyle = "#fff";
    ctx.fillText(`LIVES: ${lives}`, 12, 22);
    ctx.fillText(`COINS: ${coins}`, 12, 38);

    if (slowTimer > 0) ctx.fillText(`QUIET: ${Math.ceil(slowTimer/60)}s`, 12, 54);

    // popup (top)
    if (popup){
      const alpha = popup.t < 15 ? popup.t/15 : (popup.t > popup.ttl-15 ? (popup.ttl - popup.t)/15 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.fillText(popup.text, innerWidth/2, 110);
      if (popup.sub) ctx.fillText(popup.sub, innerWidth/2, 130);
      ctx.textAlign = "left";
      ctx.globalAlpha = 1;
    }

    // whisper near ground
    if (whisper){
      const alpha = whisper.t < 10 ? whisper.t/10 : (whisper.t > whisper.ttl-10 ? (whisper.ttl - whisper.t)/10 : 1);
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.textAlign = "center";
      ctx.fillStyle = "#fff";
      ctx.fillText(whisper.text, innerWidth/2, GROUND_Y() - 10);
      ctx.textAlign = "left";
      ctx.globalAlpha = 1;
    }

    // overlays
    if (mode === "pause"){
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle = "#fff";
      ctx.font = "12px 'Press Start 2P'";
      drawTextCenter(["PAUSED"], innerHeight/2 - 90, 18);

      ctx.font = "10px 'Press Start 2P'";
      const resumeBtn = drawButtonCentered("RESUME", innerHeight/2 - 40);
      const quitBtn   = drawButtonCentered("QUIT", innerHeight/2 + 20);

      overlayButtons = { resumeBtn, quitBtn, tryAgainBtn:null };
    }

    if (mode === "gameover"){
      ctx.fillStyle = "rgba(0,0,0,0.82)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle = "#fff";
      ctx.font = "10px 'Press Start 2P'";
      drawTextCenter([`You caught ${lastObstacleLabel}.`, "GAME OVER"], innerHeight/2 - 60, 18);

      ctx.font = "9px 'Press Start 2P'";
      drawTextCenter(["Try again â€” or donâ€™t. Weâ€™ll be here."], innerHeight/2 - 10, 16);

      ctx.font = "10px 'Press Start 2P'";
      const tryAgainBtn = drawButtonCentered("TRY AGAIN", innerHeight/2 + 35);
      overlayButtons = { resumeBtn:null, quitBtn:null, tryAgainBtn };
    }

    if (mode === "ending"){
      ctx.fillStyle = "rgba(0,0,0,0.86)";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle = "#fff";
      ctx.font = "10px 'Press Start 2P'";
      drawTextCenter([
        "CONGRATULATIONS.",
        "YOU ARE NOW A SPIRITUAL BEING",
        "WHO HAD A HUMAN EXPERIENCE."
      ], innerHeight/2 - 85, 18);

      ctx.font = "10px 'Press Start 2P'";
      const tryAgainBtn = drawButtonCentered("TRY AGAIN", innerHeight/2 + 35);
      overlayButtons = { resumeBtn:null, quitBtn:null, tryAgainBtn };
    }
  }

  function pointInRect(px, py, r){
    return r && px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
  }

  function handlePointer(px, py){
    if (mode === "pause"){
      if (pointInRect(px, py, overlayButtons.resumeBtn)) mode = "play";
      if (pointInRect(px, py, overlayButtons.quitBtn)) resetGame();
      return;
    }
    if (mode === "gameover" || mode === "ending"){
      if (pointInRect(px, py, overlayButtons.tryAgainBtn)) resetGame();
      return;
    }
  }

  canvas.addEventListener("click", (e) => {
    const r = canvas.getBoundingClientRect();
    handlePointer(e.clientX - r.left, e.clientY - r.top);
  });
  canvas.addEventListener("touchstart", (e) => {
    const t = e.touches[0]; if (!t) return;
    const r = canvas.getBoundingClientRect();
    handlePointer(t.clientX - r.left, t.clientY - r.top);
  }, {passive:true});

  function loop(){
    if (mode === "play") update();
    draw();
    requestAnimationFrame(loop);
  }

  // init
  player.y = GROUND_Y() - player.h;
  player.onGround = true;
  maybeStatusUpdate();
  loop();

})();
</script>
</body>
</html>
