<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Trudge Brothers — Opening Scene</title>
  <style>
    :root { color-scheme: dark; }
    html,body{ margin:0; height:100%; background:#0b1020; }
    canvas{
      display:block;
      margin:0 auto;
      width:min(100vw, 960px);
      height:auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:#0b1020;
      touch-action: manipulation;
    }
    .hint{
      position:fixed; left:0; right:0; bottom:10px;
      text-align:center; font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:rgba(255,255,255,.75);
      pointer-events:none;
      text-shadow:0 2px 10px rgba(0,0,0,.6);
    }
  </style>
</head>
<body>
<canvas id="c" width="512" height="288"></canvas>
<div class="hint">Click / Tap once to enable audio • Press Space/Enter to advance • M to mute</div>

<script>
(() => {
  // --- Canvas / scaling ---
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  // --- Tiny "Zelda-like" chiptune using WebAudio (no files needed) ---
  let AC = null, master = null, musicOn = true, audioEnabled = false;
  function initAudio(){
    if (audioEnabled) return;
    AC = new (window.AudioContext || window.webkitAudioContext)();
    master = AC.createGain();
    master.gain.value = 0.18;
    master.connect(AC.destination);
    audioEnabled = true;
    startMusic();
  }

  function beep(freq, t, dur, type="square", gain=0.08){
    if (!audioEnabled || !musicOn) return;
    const o = AC.createOscillator();
    const g = AC.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.connect(g); g.connect(master);
    o.start(t); o.stop(t + dur + 0.02);
  }

  function startMusic(){
    if (!audioEnabled) return;
    const base = 220; // A3-ish vibe
    // Simple looping arpeggio/pad combo
    const pattern = [0, 7, 12, 7, 0, 7, 14, 7]; // A, E, A, E, A, E, B, E
    const scale = [0,2,4,5,7,9,11,12]; // major-ish
    let step = 0;
    const bpm = 92;
    const spb = 60 / bpm;
    function tick(){
      if (!audioEnabled || !musicOn) return;
      const t = AC.currentTime + 0.02;
      const p = pattern[step % pattern.length];
      const note = base * Math.pow(2, p/12);
      // lead arpeggio
      beep(note, t, spb*0.45, "square", 0.06);
      // soft "pad" under it
      beep(note/2, t, spb*0.9, "triangle", 0.03);
      // occasional sparkle
      if (step % 8 === 0) beep(note*2, t, spb*0.2, "sine", 0.02);
      step++;
      setTimeout(tick, spb*1000);
    }
    tick();
  }

  // --- Input ---
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    keys.add(e.code);
    if (["Space","Enter","KeyM"].includes(e.code)) e.preventDefault();
    if (e.code === "KeyM") musicOn = !musicOn;
    if (e.code === "Space" || e.code === "Enter") advance();
  });
  window.addEventListener("keyup", (e)=> keys.delete(e.code));
  window.addEventListener("pointerdown", () => initAudio(), { passive:true });
  window.addEventListener("click", () => initAudio(), { passive:true });
  window.addEventListener("touchstart", () => initAudio(), { passive:true });
  canvas.addEventListener("pointerdown", () => { initAudio(); advance(); }, { passive:true });

  // --- Helpers ---
  const W = canvas.width, H = canvas.height;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // --- Scene state machine ---
  const scene = {
    idx: 0, // step in script
    timer: 0,
    flash: 0,        // 0..1
    shake: 0,        // px intensity
    invert: 0,       // 0..1
    title: false,
    fadeToTitle: 0,  // 0..1
    blink: 0,
    rain: [],
    noiseSeed: 12345,
    bill: { x: 160, y: 160, pose: "sleep" }, // pose: sleep, sit, kneel, stunned
    msg: "",
    msg2: "",
    typing: { text:"", at:0, speed: 30, done:false },
    allowAdvance: false
  };

  function setMessage(a, b=""){
    scene.msg = a;
    scene.msg2 = b;
    const full = b ? (a + "\n" + b) : a;
    scene.typing.text = full;
    scene.typing.at = 0;
    scene.typing.done = false;
    scene.allowAdvance = false;
    scene.timer = 0;
  }

  function typeUpdate(dt){
    if (scene.typing.done) return;
    scene.typing.at += dt * scene.typing.speed;
    if (scene.typing.at >= scene.typing.text.length){
      scene.typing.at = scene.typing.text.length;
      scene.typing.done = true;
      // small delay before allowing advance
      if (scene.timer > 0.25) scene.allowAdvance = true;
    }
  }

  function currentTyped(){
    return scene.typing.text.slice(0, Math.floor(scene.typing.at));
  }

  // --- Script beats ---
  // subtle humor = "Again." + a couple tiny winks without clowning it
  const beats = [
    () => { // 0
      scene.title = false;
      scene.bill.pose = "sleep";
      scene.fadeToTitle = 0;
      setMessage("Townes Hospital…", "Again.");
    },
    () => { // 1
      scene.bill.pose = "sit";
      setMessage("Bill wakes up, blinking at the ceiling.", "“Not this place again…”");
    },
    () => { // 2
      scene.bill.pose = "kneel";
      setMessage("He whispers, then it comes out loud:", "“If there is a God— show Himself to me!”");
    },
    () => { // 3 flash/shake
      scene.bill.pose = "kneel";
      scene.flash = 1;
      scene.shake = 10;
      scene.invert = 1;
      setMessage(""); // no text during the hit
      // a quick "holy moment" sound flourish
      if (audioEnabled){
        const t = AC.currentTime + 0.02;
        beep(440, t, 0.10, "sine", 0.03);
        beep(660, t+0.06, 0.12, "sine", 0.03);
        beep(880, t+0.12, 0.16, "sine", 0.03);
      }
    },
    () => { // 4 aftermath
      scene.bill.pose = "stunned";
      setMessage("Everything goes quiet.", "Bill sits up like he just got unplugged and rebooted.");
    },
    () => { // 5 idea
      scene.bill.pose = "sit";
      setMessage("He says it out loud— like it’s brand new:", "“What if I can get these drunks helping each other?”");
    },
    () => { // 6 fade to title
      scene.bill.pose = "sit";
      scene.fadeToTitle = 0;
      setMessage(""); // title takes over
    },
  ];

  function start(){
    // rain particles
    scene.rain = Array.from({length: 70}, () => ({
      x: Math.random()*W,
      y: Math.random()*H,
      v: 90 + Math.random()*120,
      l: 6 + Math.random()*10
    }));
    beats[0]();
  }

  function advance(){
    // during typing, first press completes typing
    if (!scene.typing.done && scene.typing.text.length){
      scene.typing.at = scene.typing.text.length;
      scene.typing.done = true;
      scene.allowAdvance = true;
      return;
    }
    if (!scene.allowAdvance && scene.idx !== 3 && scene.idx !== 6) return;

    // special: flash beat auto-resolves
    if (scene.idx === 3){
      // ignore manual advance during flash
      return;
    }

    scene.idx++;
    if (scene.idx >= beats.length){
      // lock at title
      scene.idx = beats.length - 1;
      scene.title = true;
      return;
    }
    beats[scene.idx]();
  }

  // --- Drawing primitives: "SNES-ish" chunky pixel art via rectangles ---
  function fillRect(x,y,w,h, color){
    ctx.fillStyle = color;
    ctx.fillRect(x|0, y|0, w|0, h|0);
  }

  function drawPixelText(text, x, y, scale=1, maxWidth=W-20){
    // tiny built-in 3x5-ish font using canvas fillText (kept simple)
    // We still render it with crisp scaling by drawing at native res.
    ctx.font = `${8*scale}px monospace`;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    const lines = (text || "").split("\n");
    for (let i=0;i<lines.length;i++){
      const line = lines[i];
      ctx.fillText(line, x, y + i*(10*scale));
    }
  }

  function drawTextBox(text){
    const boxH = 72;
    const pad = 10;
    // box
    fillRect(12, H - boxH - 12, W - 24, boxH, "rgba(0,0,0,0.72)");
    // border
    ctx.strokeStyle = "rgba(255,255,255,0.45)";
    ctx.lineWidth = 1;
    ctx.strokeRect(12.5, H - boxH - 11.5, W - 25, boxH - 1);

    // text
    drawPixelText(text, 20, H - boxH, 1.2);
    // prompt
    if (scene.typing.done){
      const prompt = "▶";
      ctx.globalAlpha = 0.75 + 0.25*Math.sin(scene.blink);
      drawPixelText(prompt, W - 26, H - 26, 1.2);
      ctx.globalAlpha = 1;
    }
  }

  function drawHospitalRoom(){
    // back wall gradient-ish
    fillRect(0,0,W,H, "#0b1020");
    fillRect(0,0,W,H, "rgba(18,30,60,0.35)");
    // window
    fillRect(340, 40, 120, 80, "rgba(20,30,60,0.8)");
    // window frame
    ctx.strokeStyle = "rgba(255,255,255,0.22)";
    ctx.strokeRect(340.5,40.5,120,80);
    ctx.strokeRect(399.5,40.5,1,80);
    ctx.strokeRect(340.5,79.5,120,1);

    // rain outside
    ctx.fillStyle = "rgba(190,210,255,0.22)";
    for (const r of scene.rain){
      ctx.fillRect(r.x|0, r.y|0, 1, r.l|0);
    }

    // bed
    fillRect(90, 140, 210, 70, "rgba(80,100,150,0.35)");
    fillRect(95, 145, 200, 60, "rgba(220,230,255,0.08)");
    // pillow
    fillRect(105, 150, 40, 18, "rgba(240,245,255,0.18)");
    // bedside table
    fillRect(310, 160, 40, 35, "rgba(120,90,60,0.25)");
    // monitor beep box
    fillRect(320, 130, 30, 18, "rgba(0,0,0,0.55)");
    fillRect(323, 133, 24, 12, "rgba(20,255,130,0.08)");
    // little cross on wall (churchy wink? keep subtle)
    fillRect(60, 55, 4, 18, "rgba(255,255,255,0.20)");
    fillRect(54, 62, 16, 4, "rgba(255,255,255,0.20)");
  }

  function drawBill(){
    // Simple sprite: head/body/arms, different poses
    const x = scene.bill.x, y = scene.bill.y;
    const skin = "rgba(255,220,180,0.7)";
    const suit = "rgba(30,30,40,0.75)";
    const outline = "rgba(0,0,0,0.45)";

    function px(x0,y0,w,h,c){ fillRect(x+x0, y+y0, w,h,c); }

    // shadow
    fillRect(x+18, y+52, 22, 4, "rgba(0,0,0,0.25)");

    if (scene.bill.pose === "sleep"){
      // lying down
      px(18, 28, 28, 16, suit);
      px(44, 30, 12, 14, suit);
      px(10, 30, 10, 10, suit);

      px(44, 24, 12, 10, skin); // head
      px(46, 26, 2, 2, "rgba(0,0,0,0.35)"); // eye
      px(49, 28, 3, 1, "rgba(0,0,0,0.25)");

    } else {
      // standing-ish torso
      px(26, 26, 16, 22, suit);
      px(26, 48, 16, 10, "rgba(60,60,80,0.75)");
      px(28, 18, 12, 10, skin); // head
      px(30, 21, 2, 2, "rgba(0,0,0,0.4)");
      px(35, 21, 2, 2, "rgba(0,0,0,0.4)");

      // mouth: changes with pose
      if (scene.bill.pose === "sit"){
        px(33, 25, 3, 1, "rgba(0,0,0,0.25)");
      } else if (scene.bill.pose === "kneel"){
        px(33, 25, 4, 1, "rgba(0,0,0,0.35)");
      } else if (scene.bill.pose === "stunned"){
        px(34, 25, 2, 2, "rgba(0,0,0,0.30)");
      }

      // arms / pose changes
      if (scene.bill.pose === "sit"){
        px(22, 30, 4, 14, suit);
        px(42, 30, 4, 14, suit);
        // legs tucked
        px(26, 58, 6, 10, suit);
        px(36, 58, 6, 10, suit);
      } else if (scene.bill.pose === "kneel"){
        // arms up / praying
        px(20, 28, 6, 10, suit);
        px(42, 28, 6, 10, suit);
        px(23, 24, 4, 6, suit);
        px(41, 24, 4, 6, suit);
        // kneeling legs
        px(26, 56, 8, 12, suit);
        px(34, 58, 10, 10, suit);
      } else if (scene.bill.pose === "stunned"){
        // arms droop
        px(22, 34, 4, 12, suit);
        px(42, 34, 4, 12, suit);
        // legs
        px(27, 58, 6, 12, suit);
        px(36, 58, 6, 12, suit);
      }

      // outline bits
      ctx.strokeStyle = outline;
      ctx.strokeRect(x+26.5, y+26.5, 16, 22);
      ctx.strokeRect(x+28.5, y+18.5, 12, 10);
    }
  }

  function drawTitle(){
    // background: warm hopeful dawn gradient blocks
    fillRect(0,0,W,H, "#1a1230");
    fillRect(0,0,W,H, "rgba(255,160,80,0.08)");
    // big stripes
    for (let i=0;i<10;i++){
      fillRect(0, i*30, W, 12, `rgba(255,255,255,${0.03 + (i%2)*0.02})`);
    }

    // "church basement doors" silhouette
    fillRect(190, 120, 132, 110, "rgba(0,0,0,0.35)");
    fillRect(200, 130, 52, 90, "rgba(0,0,0,0.45)");
    fillRect(260, 130, 52, 90, "rgba(0,0,0,0.45)");
    // little light crack
    fillRect(255, 132, 2, 86, "rgba(255,255,255,0.10)");

    // Title text
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "28px monospace";
    ctx.fillText("TRUDGE BROTHERS", 64, 84);

    ctx.font = "14px monospace";
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.fillText("Start to Surrender", 150, 108);

    // Blinking prompt
    scene.blink += 0.08;
    const a = 0.55 + 0.45*Math.sin(scene.blink);
    ctx.globalAlpha = a;
    ctx.font = "16px monospace";
    ctx.fillText("PRESS START", 186, 256);
    ctx.globalAlpha = 1;
  }

  function applyFlashAndInvert(){
    if (scene.invert > 0.001){
      // invert approximation: draw current frame to temp via getImageData (small canvas, fine)
      const img = ctx.getImageData(0,0,W,H);
      const d = img.data;
      const inv = scene.invert;
      for (let i=0;i<d.length;i+=4){
        d[i]   = lerp(d[i],   255 - d[i],   inv);
        d[i+1] = lerp(d[i+1], 255 - d[i+1], inv);
        d[i+2] = lerp(d[i+2], 255 - d[i+2], inv);
      }
      ctx.putImageData(img,0,0);
    }
    if (scene.flash > 0.001){
      ctx.globalAlpha = scene.flash;
      fillRect(0,0,W,H, "#ffffff");
      ctx.globalAlpha = 1;
    }
  }

  // --- Main loop ---
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    // update rain
    for (const r of scene.rain){
      r.y += r.v * dt;
      r.x -= 12 * dt;
      if (r.y > 120){ // keep rain mainly in window area
        r.y = 40 - Math.random()*20;
        r.x = 340 + Math.random()*120;
      }
    }

    // handle beat timing
    scene.timer += dt;
    scene.blink += dt * 6;

    // flash beat auto decay + auto advance
    if (scene.idx === 3){
      scene.flash = clamp(scene.flash - dt*1.8, 0, 1);
      scene.invert = clamp(scene.invert - dt*1.2, 0, 1);
      scene.shake = clamp(scene.shake - dt*18, 0, 12);
      // after ~0.9s, move to aftermath
      if (scene.timer > 0.9){
        scene.idx++;
        beats[scene.idx]();
      }
    }

    // allow advance after some delay when typing done
    if (scene.typing.done && scene.timer > 0.35 && scene.idx !== 6) scene.allowAdvance = true;

    // typewriter
    typeUpdate(dt);

    // fade to title
    if (scene.idx === 6){
      scene.fadeToTitle = clamp(scene.fadeToTitle + dt*0.9, 0, 1);
      if (scene.fadeToTitle > 0.6) scene.title = true;
    }

    // --- Draw ---
    ctx.save();

    // camera shake
    const sx = (Math.random()*2-1) * scene.shake;
    const sy = (Math.random()*2-1) * scene.shake;
    ctx.translate(sx|0, sy|0);

    if (!scene.title){
      drawHospitalRoom();
      drawBill();

      // typed text box
      const typed = currentTyped();
      if (typed && scene.idx !== 3) drawTextBox(typed);

      // subtle "beep" indicator
      if (scene.idx <= 2){
        const pulse = 0.5 + 0.5*Math.sin(now*0.006);
        ctx.globalAlpha = 0.15 + 0.15*pulse;
        fillRect(325, 135, 20, 8, "rgba(20,255,130,1)");
        ctx.globalAlpha = 1;
      }
    } else {
      drawTitle();
    }

    ctx.restore();

    // apply global effects AFTER drawing
    if (!scene.title){
      applyFlashAndInvert();
      // fade to title overlay
      if (scene.idx === 6){
        ctx.globalAlpha = scene.fadeToTitle;
        fillRect(0,0,W,H, "#000000");
        ctx.globalAlpha = 1;
        if (scene.fadeToTitle > 0.75){
          // draw title on top once fade is mostly complete
          drawTitle();
        }
      }
    }

    requestAnimationFrame(frame);
  }

  start();
  requestAnimationFrame(frame);

  // Optional: helpful console notes
  console.log("Trudge Brothers intro loaded. Click/tap to enable audio. Space/Enter advances. M mutes.");
})();
</script>
</body>
</html>
